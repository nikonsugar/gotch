package tensor

// NOTE. THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

import(
  "log"

  "github.com/sugarme/gotch"
)


func(ts *Tensor) Must__And_(other *Scalar)() { 
  
  err := ts.__And_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__And1(other *Tensor)() { 
  
  err := ts.__And1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Iand_(other *Scalar)() { 
  
  err := ts.__Iand_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Iand1(other *Tensor)() { 
  
  err := ts.__Iand1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Ilshift_(other *Scalar)() { 
  
  err := ts.__Ilshift_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Ilshift1(other *Tensor)() { 
  
  err := ts.__Ilshift1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Ior_(other *Scalar)() { 
  
  err := ts.__Ior_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Ior1(other *Tensor)() { 
  
  err := ts.__Ior1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Irshift_(other *Scalar)() { 
  
  err := ts.__Irshift_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Irshift1(other *Tensor)() { 
  
  err := ts.__Irshift1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Ixor_(other *Scalar)() { 
  
  err := ts.__Ixor_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Ixor1(other *Tensor)() { 
  
  err := ts.__Ixor1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Lshift_(other *Scalar)() { 
  
  err := ts.__Lshift_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Lshift1(other *Tensor)() { 
  
  err := ts.__Lshift1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Or_(other *Scalar)() { 
  
  err := ts.__Or_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Or1(other *Tensor)() { 
  
  err := ts.__Or1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Rshift_(other *Scalar)() { 
  
  err := ts.__Rshift_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Rshift1(other *Tensor)() { 
  
  err := ts.__Rshift1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Xor_(other *Scalar)() { 
  
  err := ts.__Xor_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must__Xor1(other *Tensor)() { 
  
  err := ts.__Xor1(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_AdaptiveAvgPool2d(outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._AdaptiveAvgPool2d(outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_AdaptiveAvgPool2dBackward(gradOutput *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._AdaptiveAvgPool2dBackward(gradOutput, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_AddBatchDim(batchDim int64, level int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._AddBatchDim(batchDim, level, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_AddRelu(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._AddRelu(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_AddRelu_(other *Tensor)() { 
  
  err := ts._AddRelu_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_AddReluOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._AddReluOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_AddmvImpl_(self2 *Tensor, mat *Tensor, vec *Tensor)() { 
  
  err := ts._AddmvImpl_(self2, mat, vec)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func Must_AmpUpdateScale(growthTracker *Tensor, currentScale *Tensor, foundInf *Tensor, scaleGrowthFactor float64, scaleBackoffFactor float64, growthInterval int64)(retVal *Tensor) { 
  
  retVal, err := _AmpUpdateScale(growthTracker, currentScale, foundInf, scaleGrowthFactor, scaleBackoffFactor, growthInterval)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_BaddbmmMkl_(batch1 *Tensor, batch2 *Tensor)() { 
  
  err := ts._BaddbmmMkl_(batch1, batch2)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_Bmm(mat2 *Tensor, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Bmm(mat2, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_BmmOut(out *Tensor, mat2 *Tensor, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._BmmOut(out, mat2, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastByte(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastByte(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastChar(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastChar(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastDouble(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastDouble(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastFloat(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastFloat(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastHalf(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastHalf(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastInt(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastInt(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastLong(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastLong(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CastShort(nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CastShort(nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_Cat(tensors []Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := _Cat(tensors, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_CatOut(out *Tensor, tensors []Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := _CatOut(out, tensors, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_CdistBackward(grad *Tensor, x1 *Tensor, x2 *Tensor, p float64, cdist *Tensor)(retVal *Tensor) { 
  
  retVal, err := _CdistBackward(grad, x1, x2, p, cdist)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CholeskyHelper(upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CholeskyHelper(upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CholeskySolveHelper(a *Tensor, upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CholeskySolveHelper(a, upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Coalesced_(coalesced bool)() { 
  
  err := ts._Coalesced_(coalesced)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func Must_ComputeLinearCombination(input *Tensor, coefficients *Tensor)(retVal *Tensor) { 
  
  retVal, err := _ComputeLinearCombination(input, coefficients)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_ComputeLinearCombinationOut(out *Tensor, input *Tensor, coefficients *Tensor)(retVal *Tensor) { 
  
  retVal, err := _ComputeLinearCombinationOut(out, input, coefficients)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Conj(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Conj(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_Convolution(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, transposed bool, outputPadding []int64, groups int64, benchmark bool, deterministic bool, cudnnEnabled bool)(retVal *Tensor) { 
  
  retVal, err := _Convolution(input, weight, bias, stride, padding, dilation, transposed, outputPadding, groups, benchmark, deterministic, cudnnEnabled)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_Convolution1(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, transposed bool, outputPadding []int64, groups int64, benchmark bool, deterministic bool, cudnnEnabled bool, allowTf32 bool)(retVal *Tensor) { 
  
  retVal, err := _Convolution1(input, weight, bias, stride, padding, dilation, transposed, outputPadding, groups, benchmark, deterministic, cudnnEnabled, allowTf32)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_ConvolutionNogroup(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, transposed bool, outputPadding []int64)(retVal *Tensor) { 
  
  retVal, err := _ConvolutionNogroup(input, weight, bias, stride, padding, dilation, transposed, outputPadding)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CopyFrom(dst *Tensor, nonBlocking bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CopyFrom(dst, nonBlocking, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_CtcLossBackward(grad *Tensor, logProbs *Tensor, targets *Tensor, inputLengths []int64, targetLengths []int64, negLogLikelihood *Tensor, logAlpha *Tensor, blank int64, zeroInfinity bool)(retVal *Tensor) { 
  
  retVal, err := _CtcLossBackward(grad, logProbs, targets, inputLengths, targetLengths, negLogLikelihood, logAlpha, blank, zeroInfinity)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_CudnnInitDropoutState(dropout float64, train bool, dropoutSeed int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := _CudnnInitDropoutState(dropout, train, dropoutSeed, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_CudnnRnnFlattenWeight(weightArr []Tensor, weightStride0 int64, inputSize int64, mode int64, hiddenSize int64, numLayers int64, batchFirst bool, bidirectional bool)(retVal *Tensor) { 
  
  retVal, err := _CudnnRnnFlattenWeight(weightArr, weightStride0, inputSize, mode, hiddenSize, numLayers, batchFirst, bidirectional)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Cumprod(dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Cumprod(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CumprodOut(out *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CumprodOut(out, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Cumsum(dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Cumsum(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_CumsumOut(out *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._CumsumOut(out, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_DimArange(like *Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := _DimArange(like, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_DirichletGrad(x *Tensor, alpha *Tensor, total *Tensor)(retVal *Tensor) { 
  
  retVal, err := _DirichletGrad(x, alpha, total)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_EmbeddingBagBackward(grad *Tensor, indices *Tensor, offsets *Tensor, offset2bag *Tensor, bagSize *Tensor, maximumIndices *Tensor, numWeights int64, scaleGradByFreq bool, mode int64, sparse bool, perSampleWeights *Tensor)(retVal *Tensor) { 
  
  retVal, err := _EmbeddingBagBackward(grad, indices, offsets, offset2bag, bagSize, maximumIndices, numWeights, scaleGradByFreq, mode, sparse, perSampleWeights)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_EmbeddingBagDenseBackward(grad *Tensor, indices *Tensor, offsets *Tensor, offset2bag *Tensor, bagSize *Tensor, maximumIndices *Tensor, numWeights int64, scaleGradByFreq bool, mode int64, perSampleWeights *Tensor)(retVal *Tensor) { 
  
  retVal, err := _EmbeddingBagDenseBackward(grad, indices, offsets, offset2bag, bagSize, maximumIndices, numWeights, scaleGradByFreq, mode, perSampleWeights)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_EmbeddingBagPerSampleWeightsBackward(grad *Tensor, weight *Tensor, indices *Tensor, offsets *Tensor, offset2bag *Tensor, mode int64)(retVal *Tensor) { 
  
  retVal, err := _EmbeddingBagPerSampleWeightsBackward(grad, weight, indices, offsets, offset2bag, mode)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_EmbeddingBagSparseBackward(grad *Tensor, indices *Tensor, offsets *Tensor, offset2bag *Tensor, bagSize *Tensor, numWeights int64, scaleGradByFreq bool, mode int64, perSampleWeights *Tensor)(retVal *Tensor) { 
  
  retVal, err := _EmbeddingBagSparseBackward(grad, indices, offsets, offset2bag, bagSize, numWeights, scaleGradByFreq, mode, perSampleWeights)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_EmptyAffineQuantized(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device, scale float64, zeroPoint int64)(retVal *Tensor) { 
  
  retVal, err := _EmptyAffineQuantized(size, optionsKind, optionsDevice, scale, zeroPoint)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_EmptyPerChannelAffineQuantized(size []int64, scales *Tensor, zeroPoints *Tensor, axis int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := _EmptyPerChannelAffineQuantized(size, scales, zeroPoints, axis, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_EuclideanDist(x1 *Tensor, x2 *Tensor)(retVal *Tensor) { 
  
  retVal, err := _EuclideanDist(x1, x2)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_FakeQuantizeLearnablePerChannelAffine(scale *Tensor, zeroPoint *Tensor, axis int64, quantMin int64, quantMax int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._FakeQuantizeLearnablePerChannelAffine(scale, zeroPoint, axis, quantMin, quantMax, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_FakeQuantizeLearnablePerTensorAffine(scale *Tensor, zeroPoint *Tensor, quantMin int64, quantMax int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._FakeQuantizeLearnablePerTensorAffine(scale, zeroPoint, quantMin, quantMax, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_FftWithSize(signalNdim int64, complexInput bool, complexOutput bool, inverse bool, checkedSignalSizes []int64, normalized bool, onesided bool, outputSizes []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._FftWithSize(signalNdim, complexInput, complexOutput, inverse, checkedSignalSizes, normalized, onesided, outputSizes, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_FftWithSize1(signalNdim int64, complexInput bool, complexOutput bool, inverse bool, checkedSignalSizes []int64, normalization int64, onesided bool, outputSizes []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._FftWithSize1(signalNdim, complexInput, complexOutput, inverse, checkedSignalSizes, normalization, onesided, outputSizes, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_GatherSparseBackward(dim int64, index *Tensor, grad *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._GatherSparseBackward(dim, index, grad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_GridSampler2dCpuFallback(input *Tensor, grid *Tensor, interpolationMode int64, paddingMode int64, alignCorners bool)(retVal *Tensor) { 
  
  retVal, err := _GridSampler2dCpuFallback(input, grid, interpolationMode, paddingMode, alignCorners)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_IndexCopy_(dim int64, index *Tensor, source *Tensor)() { 
  
  err := ts._IndexCopy_(dim, index, source)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_IndexPutImpl_(indices []Tensor, values *Tensor, accumulate bool, unsafety bool)() { 
  
  err := ts._IndexPutImpl_(indices, values, accumulate, unsafety)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_Indices(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Indices(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_InverseHelper(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._InverseHelper(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_LogSoftmax(dim int64, halfToFloat bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._LogSoftmax(dim, halfToFloat, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_LogSoftmaxBackwardData(gradOutput *Tensor, output *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._LogSoftmaxBackwardData(gradOutput, output, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Logcumsumexp(dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Logcumsumexp(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_LogcumsumexpOut(out *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._LogcumsumexpOut(out, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_LuSolveHelper(lUData *Tensor, lUPivots *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._LuSolveHelper(lUData, lUPivots, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_MakePerChannelQuantizedTensor(scale *Tensor, zeroPoint *Tensor, axis int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._MakePerChannelQuantizedTensor(scale, zeroPoint, axis, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_MakePerTensorQuantizedTensor(scale float64, zeroPoint int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._MakePerTensorQuantizedTensor(scale, zeroPoint, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_MaskedScale(mask *Tensor, scale float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._MaskedScale(mask, scale, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_MkldnnReshape(shape []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._MkldnnReshape(shape, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_MkldnnTranspose(dim0 int64, dim1 int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._MkldnnTranspose(dim0, dim1, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_MkldnnTranspose_(dim0 int64, dim1 int64)() { 
  
  err := ts._MkldnnTranspose_(dim0, dim1)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func Must_MultinomialAliasDraw(j *Tensor, q *Tensor, numSamples int64)(retVal *Tensor) { 
  
  retVal, err := _MultinomialAliasDraw(j, q, numSamples)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_NnpackSpatialConvolution(input *Tensor, weight *Tensor, bias *Tensor, padding []int64, stride []int64)(retVal *Tensor) { 
  
  retVal, err := _NnpackSpatialConvolution(input, weight, bias, padding, stride)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_NnpackSpatialConvolutionBackwardInput(input *Tensor, gradOutput *Tensor, weight *Tensor, padding []int64)(retVal *Tensor) { 
  
  retVal, err := _NnpackSpatialConvolutionBackwardInput(input, gradOutput, weight, padding)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_NnpackSpatialConvolutionBackwardWeight(input *Tensor, weightsize []int64, gradOutput *Tensor, padding []int64)(retVal *Tensor) { 
  
  retVal, err := _NnpackSpatialConvolutionBackwardWeight(input, weightsize, gradOutput, padding)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_PackPaddedSequenceBackward(grad *Tensor, inputSize []int64, batchSizes *Tensor, batchFirst bool)(retVal *Tensor) { 
  
  retVal, err := _PackPaddedSequenceBackward(grad, inputSize, batchSizes, batchFirst)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_PdistBackward(grad *Tensor, p float64, pdist *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._PdistBackward(grad, p, pdist, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_RemoveBatchDim(level int64, batchSize int64, outDim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._RemoveBatchDim(level, batchSize, outDim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_ReshapeFromTensor(shape *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._ReshapeFromTensor(shape, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SWhere(condition *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SWhere(condition, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SampleDirichlet(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SampleDirichlet(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_SaturateWeightToFp16(weight *Tensor)(retVal *Tensor) { 
  
  retVal, err := _SaturateWeightToFp16(weight)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_ShapeAsTensor(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._ShapeAsTensor(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SobolEngineFf_(n int64, sobolstate *Tensor, dimension int64, numGenerated int64)() { 
  
  err := ts._SobolEngineFf_(n, sobolstate, dimension, numGenerated)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_SobolEngineInitializeState_(dimension int64)() { 
  
  err := ts._SobolEngineInitializeState_(dimension)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_SobolEngineScramble_(ltm *Tensor, dimension int64)() { 
  
  err := ts._SobolEngineScramble_(ltm, dimension)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) Must_Softmax(dim int64, halfToFloat bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Softmax(dim, halfToFloat, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SoftmaxBackwardData(gradOutput *Tensor, output *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SoftmaxBackwardData(gradOutput, output, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseAddmm(sparse *Tensor, dense *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseAddmm(sparse, dense, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_SparseCooTensorUnsafe(indices *Tensor, values *Tensor, size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := _SparseCooTensorUnsafe(indices, values, size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_SparseCooTensorWithDims(sparseDim int64, denseDim int64, size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := _SparseCooTensorWithDims(sparseDim, denseDim, size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_SparseCooTensorWithDimsAndTensors(sparseDim int64, denseDim int64, size []int64, indices *Tensor, values *Tensor, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := _SparseCooTensorWithDimsAndTensors(sparseDim, denseDim, size, indices, values, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseLogSoftmax(dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseLogSoftmax(dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseLogSoftmax1(dim int64, halfToFloat bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseLogSoftmax1(dim, halfToFloat, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseLogSoftmaxBackwardData(gradOutput *Tensor, output *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseLogSoftmaxBackwardData(gradOutput, output, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_SparseMm(sparse *Tensor, dense *Tensor)(retVal *Tensor) { 
  
  retVal, err := _SparseMm(sparse, dense)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSoftmax(dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSoftmax(dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSoftmax1(dim int64, halfToFloat bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSoftmax1(dim, halfToFloat, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSoftmaxBackwardData(gradOutput *Tensor, output *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSoftmaxBackwardData(gradOutput, output, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSum(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSum(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSum1(dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSum1(dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSum2(dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSum2(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSum3(dim []int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSum3(dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_SparseSumBackward(grad *Tensor, dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._SparseSumBackward(grad, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_StandardGamma(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._StandardGamma(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_StandardGammaGrad(output *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._StandardGammaGrad(output, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Std(unbiased bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Std(unbiased, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_TestOptionalFilledIntlist(values *Tensor, addends []int64)(retVal *Tensor) { 
  
  retVal, err := _TestOptionalFilledIntlist(values, addends)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_TestOptionalIntlist(values *Tensor, addends []int64)(retVal *Tensor) { 
  
  retVal, err := _TestOptionalIntlist(values, addends)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_TestSerializationSubcmul(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._TestSerializationSubcmul(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_Trilinear(i1 *Tensor, i2 *Tensor, i3 *Tensor, expand1 []int64, expand2 []int64, expand3 []int64, sumdim []int64, unrollDim int64)(retVal *Tensor) { 
  
  retVal, err := _Trilinear(i1, i2, i3, expand1, expand2, expand3, sumdim, unrollDim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_UnsafeView(size []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._UnsafeView(size, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Values(del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Values(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) Must_Var(unbiased bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts._Var(unbiased, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func Must_WeightNorm(v *Tensor, g *Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := _WeightNorm(v, g, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAbs(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Abs(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAbs_()() { 
  
  err := ts.Abs_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAbsOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AbsOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAbsolute(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Absolute(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAbsolute_()() { 
  
  err := ts.Absolute_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAbsoluteOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AbsoluteOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAcos(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Acos(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAcos_()() { 
  
  err := ts.Acos_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAcosOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AcosOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAcosh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Acosh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAcosh_()() { 
  
  err := ts.Acosh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAcoshOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AcoshOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveAvgPool1d(outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveAvgPool1d(outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveAvgPool2d(outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveAvgPool2d(outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveAvgPool2dOut(out *Tensor, outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveAvgPool2dOut(out, outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveAvgPool3d(outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveAvgPool3d(outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveAvgPool3dBackward(gradOutput *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveAvgPool3dBackward(gradOutput, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveAvgPool3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveAvgPool3dBackwardOut(gradInput, gradOutput, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveAvgPool3dOut(out *Tensor, outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveAvgPool3dOut(out, outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveMaxPool2dBackward(gradOutput *Tensor, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveMaxPool2dBackward(gradOutput, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveMaxPool2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveMaxPool2dBackwardOut(gradInput, gradOutput, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveMaxPool3dBackward(gradOutput *Tensor, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveMaxPool3dBackward(gradOutput, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdaptiveMaxPool3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AdaptiveMaxPool3dBackwardOut(gradInput, gradOutput, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdd(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Add(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdd1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Add1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAdd_(other *Tensor)() { 
  
  err := ts.Add_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAdd1_(other *Scalar)() { 
  
  err := ts.Add1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAddOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AddOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddbmm(batch1 *Tensor, batch2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Addbmm(batch1, batch2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddbmm_(batch1 *Tensor, batch2 *Tensor)() { 
  
  err := ts.Addbmm_(batch1, batch2)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAddbmmOut(out *Tensor, batch1 *Tensor, batch2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AddbmmOut(out, batch1, batch2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddcdiv(tensor1 *Tensor, tensor2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Addcdiv(tensor1, tensor2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddcdiv_(tensor1 *Tensor, tensor2 *Tensor)() { 
  
  err := ts.Addcdiv_(tensor1, tensor2)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAddcdivOut(out *Tensor, tensor1 *Tensor, tensor2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AddcdivOut(out, tensor1, tensor2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddcmul(tensor1 *Tensor, tensor2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Addcmul(tensor1, tensor2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddcmul_(tensor1 *Tensor, tensor2 *Tensor)() { 
  
  err := ts.Addcmul_(tensor1, tensor2)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAddcmulOut(out *Tensor, tensor1 *Tensor, tensor2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AddcmulOut(out, tensor1, tensor2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddmm(mat1 *Tensor, mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Addmm(mat1, mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddmm_(mat1 *Tensor, mat2 *Tensor)() { 
  
  err := ts.Addmm_(mat1, mat2)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAddmmOut(out *Tensor, mat1 *Tensor, mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AddmmOut(out, mat1, mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddmv(mat *Tensor, vec *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Addmv(mat, vec, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddmv_(mat *Tensor, vec *Tensor)() { 
  
  err := ts.Addmv_(mat, vec)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAddmvOut(out *Tensor, mat *Tensor, vec *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AddmvOut(out, mat, vec, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddr(vec1 *Tensor, vec2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Addr(vec1, vec2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAddr_(vec1 *Tensor, vec2 *Tensor)() { 
  
  err := ts.Addr_(vec1, vec2)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAddrOut(out *Tensor, vec1 *Tensor, vec2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AddrOut(out, vec1, vec2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustAffineGridGenerator(theta *Tensor, size []int64, alignCorners bool)(retVal *Tensor) { 
  
  retVal, err := AffineGridGenerator(theta, size, alignCorners)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustAffineGridGeneratorBackward(grad *Tensor, size []int64, alignCorners bool)(retVal *Tensor) { 
  
  retVal, err := AffineGridGeneratorBackward(grad, size, alignCorners)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAlias(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Alias(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAlignAs(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AlignAs(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAll(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.All(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAll1(dim int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.All1(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAllOut(out *Tensor, dim int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AllOut(out, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustAlphaDropout(input *Tensor, p float64, train bool)(retVal *Tensor) { 
  
  retVal, err := AlphaDropout(input, p, train)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAlphaDropout_(p float64, train bool)() { 
  
  err := ts.AlphaDropout_(p, train)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAmax(dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Amax(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAmaxOut(out *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AmaxOut(out, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAmin(dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Amin(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAminOut(out *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AminOut(out, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAngle(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Angle(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAngleOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AngleOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAny(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Any(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAny1(dim int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Any1(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAnyOut(out *Tensor, dim int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AnyOut(out, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustArange(end *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Arange(end, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustArange1(start *Scalar, end *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Arange1(start, end, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustArange2(start *Scalar, end *Scalar, step *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Arange2(start, end, step, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustArangeOut(out *Tensor, end *Scalar)(retVal *Tensor) { 
  
  retVal, err := ArangeOut(out, end)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustArangeOut1(out *Tensor, start *Scalar, end *Scalar)(retVal *Tensor) { 
  
  retVal, err := ArangeOut1(out, start, end)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArccos(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Arccos(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArccos_()() { 
  
  err := ts.Arccos_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustArccosOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ArccosOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArccosh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Arccosh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArccosh_()() { 
  
  err := ts.Arccosh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustArccoshOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ArccoshOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArcsin(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Arcsin(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArcsin_()() { 
  
  err := ts.Arcsin_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustArcsinOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ArcsinOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArcsinh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Arcsinh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArcsinh_()() { 
  
  err := ts.Arcsinh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustArcsinhOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ArcsinhOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArctan(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Arctan(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArctan_()() { 
  
  err := ts.Arctan_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustArctanOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ArctanOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArctanh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Arctanh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArctanh_()() { 
  
  err := ts.Arctanh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustArctanhOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ArctanhOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArgmax(dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Argmax(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArgmin(dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Argmin(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustArgsort(dim int64, descending bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Argsort(dim, descending, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAsStrided(size []int64, stride []int64, storageOffset []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AsStrided(size, stride, storageOffset, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAsStrided_(size []int64, stride []int64, storageOffset []int64)() { 
  
  err := ts.AsStrided_(size, stride, storageOffset)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAsin(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Asin(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAsin_()() { 
  
  err := ts.Asin_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAsinOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AsinOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAsinh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Asinh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAsinh_()() { 
  
  err := ts.Asinh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAsinhOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AsinhOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtan(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Atan(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtan2(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Atan2(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtan2_(other *Tensor)() { 
  
  err := ts.Atan2_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAtan2Out(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Atan2Out(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtan_()() { 
  
  err := ts.Atan_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAtanOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AtanOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtanh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Atanh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtanh_()() { 
  
  err := ts.Atanh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustAtanhOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AtanhOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtleast1d(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Atleast1d(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtleast2d(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Atleast2d(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAtleast3d(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Atleast3d(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool1d(kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool1d(kernelSize, stride, padding, ceilMode, countIncludePad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool2d(kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool2d(kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool2dBackward(gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool2dBackward(gradOutput, kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool2dBackwardOut(gradInput, gradOutput, kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool2dOut(out *Tensor, kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool2dOut(out, kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool3d(kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool3d(kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool3dBackward(gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool3dBackward(gradOutput, kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool3dBackwardOut(gradInput, gradOutput, kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustAvgPool3dOut(out *Tensor, kernelSize []int64, stride []int64, padding []int64, ceilMode bool, countIncludePad bool, divisorOverride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.AvgPool3dOut(out, kernelSize, stride, padding, ceilMode, countIncludePad, divisorOverride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBaddbmm(batch1 *Tensor, batch2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Baddbmm(batch1, batch2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBaddbmm_(batch1 *Tensor, batch2 *Tensor)() { 
  
  err := ts.Baddbmm_(batch1, batch2)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBaddbmmOut(out *Tensor, batch1 *Tensor, batch2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BaddbmmOut(out, batch1, batch2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBartlettWindow(windowLength int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := BartlettWindow(windowLength, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBartlettWindow1(windowLength int64, periodic bool, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := BartlettWindow1(windowLength, periodic, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBatchNorm(input *Tensor, weight *Tensor, bias *Tensor, runningMean *Tensor, runningVar *Tensor, training bool, momentum float64, eps float64, cudnnEnabled bool)(retVal *Tensor) { 
  
  retVal, err := BatchNorm(input, weight, bias, runningMean, runningVar, training, momentum, eps, cudnnEnabled)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBatchNormBackwardElemt(gradOut *Tensor, input *Tensor, mean *Tensor, invstd *Tensor, weight *Tensor, meanDy *Tensor, meanDyXmu *Tensor)(retVal *Tensor) { 
  
  retVal, err := BatchNormBackwardElemt(gradOut, input, mean, invstd, weight, meanDy, meanDyXmu)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBatchNormElemt(input *Tensor, weight *Tensor, bias *Tensor, mean *Tensor, invstd *Tensor, eps float64)(retVal *Tensor) { 
  
  retVal, err := BatchNormElemt(input, weight, bias, mean, invstd, eps)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBatchNormElemtOut(out *Tensor, input *Tensor, weight *Tensor, bias *Tensor, mean *Tensor, invstd *Tensor, eps float64)(retVal *Tensor) { 
  
  retVal, err := BatchNormElemtOut(out, input, weight, bias, mean, invstd, eps)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBernoulli(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Bernoulli(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBernoulli1(p float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Bernoulli1(p, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBernoulli_(p *Tensor)() { 
  
  err := ts.Bernoulli_(p)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBernoulli1_(p float64)() { 
  
  err := ts.Bernoulli1_(p)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBernoulliOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BernoulliOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBilinear(input1 *Tensor, input2 *Tensor, weight *Tensor, bias *Tensor)(retVal *Tensor) { 
  
  retVal, err := Bilinear(input1, input2, weight, bias)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBinaryCrossEntropy(target *Tensor, weight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BinaryCrossEntropy(target, weight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBinaryCrossEntropyBackward(gradOutput *Tensor, target *Tensor, weight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BinaryCrossEntropyBackward(gradOutput, target, weight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBinaryCrossEntropyBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, weight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BinaryCrossEntropyBackwardOut(gradInput, gradOutput, target, weight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBinaryCrossEntropyOut(out *Tensor, target *Tensor, weight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BinaryCrossEntropyOut(out, target, weight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBinaryCrossEntropyWithLogits(target *Tensor, weight *Tensor, posWeight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BinaryCrossEntropyWithLogits(target, weight, posWeight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBinaryCrossEntropyWithLogitsBackward(gradOutput *Tensor, target *Tensor, weight *Tensor, posWeight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BinaryCrossEntropyWithLogitsBackward(gradOutput, target, weight, posWeight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBincount(weights *Tensor, minlength int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Bincount(weights, minlength, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBinomial(count *Tensor, prob *Tensor)(retVal *Tensor) { 
  
  retVal, err := Binomial(count, prob)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseAnd(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseAnd(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseAnd1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseAnd1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseAnd_(other *Scalar)() { 
  
  err := ts.BitwiseAnd_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBitwiseAnd1_(other *Tensor)() { 
  
  err := ts.BitwiseAnd1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBitwiseAndOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseAndOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseAndOut1(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseAndOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseNot(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseNot(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseNot_()() { 
  
  err := ts.BitwiseNot_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBitwiseNotOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseNotOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseOr(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseOr(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseOr1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseOr1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseOr_(other *Scalar)() { 
  
  err := ts.BitwiseOr_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBitwiseOr1_(other *Tensor)() { 
  
  err := ts.BitwiseOr1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBitwiseOrOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseOrOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseOrOut1(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseOrOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseXor(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseXor(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseXor1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseXor1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseXor_(other *Scalar)() { 
  
  err := ts.BitwiseXor_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBitwiseXor1_(other *Tensor)() { 
  
  err := ts.BitwiseXor1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustBitwiseXorOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseXorOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBitwiseXorOut1(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BitwiseXorOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBlackmanWindow(windowLength int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := BlackmanWindow(windowLength, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBlackmanWindow1(windowLength int64, periodic bool, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := BlackmanWindow1(windowLength, periodic, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBlockDiag(tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := BlockDiag(tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBmm(mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Bmm(mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBmmOut(out *Tensor, mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BmmOut(out, mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBucketize(boundaries *Tensor, outInt32 bool, right bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Bucketize(boundaries, outInt32, right, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustBucketize1(selfScalar *Scalar, boundaries *Tensor, outInt32 bool, right bool)(retVal *Tensor) { 
  
  retVal, err := Bucketize1(selfScalar, boundaries, outInt32, right)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustBucketizeOut(out *Tensor, boundaries *Tensor, outInt32 bool, right bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.BucketizeOut(out, boundaries, outInt32, right, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCartesianProd(tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := CartesianProd(tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCat(tensors []Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := Cat(tensors, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCatOut(out *Tensor, tensors []Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := CatOut(out, tensors, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCauchy_(median float64, sigma float64)() { 
  
  err := ts.Cauchy_(median, sigma)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustCdist(x1 *Tensor, x2 *Tensor, p float64, computeMode []int64)(retVal *Tensor) { 
  
  retVal, err := Cdist(x1, x2, p, computeMode)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCeil(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ceil(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCeil_()() { 
  
  err := ts.Ceil_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustCeilOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CeilOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCelu(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Celu(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCelu_()() { 
  
  err := ts.Celu_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustChainMatmul(matrices []Tensor)(retVal *Tensor) { 
  
  retVal, err := ChainMatmul(matrices)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustChannelShuffle(groups int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ChannelShuffle(groups, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCholesky(upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Cholesky(upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCholeskyInverse(upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CholeskyInverse(upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCholeskyInverseOut(out *Tensor, upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CholeskyInverseOut(out, upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCholeskyOut(out *Tensor, upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CholeskyOut(out, upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCholeskySolve(input2 *Tensor, upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CholeskySolve(input2, upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCholeskySolveOut(out *Tensor, input2 *Tensor, upper bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CholeskySolveOut(out, input2, upper, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClamp(min *Scalar, max *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Clamp(min, max, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClamp_(min *Scalar, max *Scalar)() { 
  
  err := ts.Clamp_(min, max)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustClampMax(max *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ClampMax(max, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClampMax_(max *Scalar)() { 
  
  err := ts.ClampMax_(max)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustClampMaxOut(out *Tensor, max *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ClampMaxOut(out, max, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClampMin(min *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ClampMin(min, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClampMin_(min *Scalar)() { 
  
  err := ts.ClampMin_(min)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustClampMinOut(out *Tensor, min *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ClampMinOut(out, min, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClampOut(out *Tensor, min *Scalar, max *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ClampOut(out, min, max, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClip(min *Scalar, max *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Clip(min, max, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustClip_(min *Scalar, max *Scalar)() { 
  
  err := ts.Clip_(min, max)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustClipOut(out *Tensor, min *Scalar, max *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ClipOut(out, min, max, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCoalesce(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Coalesce(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCol2im(outputSize []int64, kernelSize []int64, dilation []int64, padding []int64, stride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Col2im(outputSize, kernelSize, dilation, padding, stride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCol2imBackward(gradOutput *Tensor, kernelSize []int64, dilation []int64, padding []int64, stride []int64)(retVal *Tensor) { 
  
  retVal, err := Col2imBackward(gradOutput, kernelSize, dilation, padding, stride)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCol2imBackwardOut(gradInput *Tensor, gradOutput *Tensor, kernelSize []int64, dilation []int64, padding []int64, stride []int64)(retVal *Tensor) { 
  
  retVal, err := Col2imBackwardOut(gradInput, gradOutput, kernelSize, dilation, padding, stride)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCol2imOut(out *Tensor, outputSize []int64, kernelSize []int64, dilation []int64, padding []int64, stride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Col2imOut(out, outputSize, kernelSize, dilation, padding, stride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCombinations(r int64, withReplacement bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Combinations(r, withReplacement, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustComplex(real *Tensor, imag *Tensor)(retVal *Tensor) { 
  
  retVal, err := Complex(real, imag)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustComplexOut(out *Tensor, real *Tensor, imag *Tensor)(retVal *Tensor) { 
  
  retVal, err := ComplexOut(out, real, imag)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustConj(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Conj(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustConjOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ConjOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustConstantPadNd(pad []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ConstantPadNd(pad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustContiguous(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Contiguous(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConv1d(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, groups int64)(retVal *Tensor) { 
  
  retVal, err := Conv1d(input, weight, bias, stride, padding, dilation, groups)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConv2d(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, groups int64)(retVal *Tensor) { 
  
  retVal, err := Conv2d(input, weight, bias, stride, padding, dilation, groups)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConv3d(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, groups int64)(retVal *Tensor) { 
  
  retVal, err := Conv3d(input, weight, bias, stride, padding, dilation, groups)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustConvTbc(weight *Tensor, bias *Tensor, pad int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ConvTbc(weight, bias, pad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConvTranspose1d(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, outputPadding []int64, groups int64, dilation []int64)(retVal *Tensor) { 
  
  retVal, err := ConvTranspose1d(input, weight, bias, stride, padding, outputPadding, groups, dilation)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConvTranspose2d(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, outputPadding []int64, groups int64, dilation []int64)(retVal *Tensor) { 
  
  retVal, err := ConvTranspose2d(input, weight, bias, stride, padding, outputPadding, groups, dilation)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConvTranspose3d(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, outputPadding []int64, groups int64, dilation []int64)(retVal *Tensor) { 
  
  retVal, err := ConvTranspose3d(input, weight, bias, stride, padding, outputPadding, groups, dilation)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConvolution(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, transposed bool, outputPadding []int64, groups int64)(retVal *Tensor) { 
  
  retVal, err := Convolution(input, weight, bias, stride, padding, dilation, transposed, outputPadding, groups)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustConvolutionOverrideable(input *Tensor, weight *Tensor, bias *Tensor, stride []int64, padding []int64, dilation []int64, transposed bool, outputPadding []int64, groups int64)(retVal *Tensor) { 
  
  retVal, err := ConvolutionOverrideable(input, weight, bias, stride, padding, dilation, transposed, outputPadding, groups)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCopySparseToSparse_(src *Tensor, nonBlocking bool)() { 
  
  err := ts.CopySparseToSparse_(src, nonBlocking)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustCos(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Cos(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCos_()() { 
  
  err := ts.Cos_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustCosOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CosOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCosh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Cosh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCosh_()() { 
  
  err := ts.Cosh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustCoshOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CoshOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCosineEmbeddingLoss(input1 *Tensor, input2 *Tensor, target *Tensor, margin float64, reduction int64)(retVal *Tensor) { 
  
  retVal, err := CosineEmbeddingLoss(input1, input2, target, margin, reduction)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCosineSimilarity(x1 *Tensor, x2 *Tensor, dim int64, eps float64)(retVal *Tensor) { 
  
  retVal, err := CosineSimilarity(x1, x2, dim, eps)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCountNonzero(dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CountNonzero(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCountNonzero1(dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CountNonzero1(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCross(other *Tensor, dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Cross(other, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCrossOut(out *Tensor, other *Tensor, dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CrossOut(out, other, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCtcLoss(logProbs *Tensor, targets *Tensor, inputLengths []int64, targetLengths []int64, blank int64, reduction int64, zeroInfinity bool)(retVal *Tensor) { 
  
  retVal, err := CtcLoss(logProbs, targets, inputLengths, targetLengths, blank, reduction, zeroInfinity)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCtcLoss1(logProbs *Tensor, targets *Tensor, inputLengths *Tensor, targetLengths *Tensor, blank int64, reduction int64, zeroInfinity bool)(retVal *Tensor) { 
  
  retVal, err := CtcLoss1(logProbs, targets, inputLengths, targetLengths, blank, reduction, zeroInfinity)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCudnnAffineGridGenerator(theta *Tensor, n int64, c int64, h int64, w int64)(retVal *Tensor) { 
  
  retVal, err := CudnnAffineGridGenerator(theta, n, c, h, w)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCudnnAffineGridGeneratorBackward(grad *Tensor, n int64, c int64, h int64, w int64)(retVal *Tensor) { 
  
  retVal, err := CudnnAffineGridGeneratorBackward(grad, n, c, h, w)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolution(weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolution(weight, padding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolution1(weight *Tensor, bias *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolution1(weight, bias, padding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolution2(weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, allowTf32 bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolution2(weight, padding, stride, dilation, groups, benchmark, deterministic, allowTf32, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCudnnConvolutionBackwardInput(selfSize []int64, gradOutput *Tensor, weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, allowTf32 bool)(retVal *Tensor) { 
  
  retVal, err := CudnnConvolutionBackwardInput(selfSize, gradOutput, weight, padding, stride, dilation, groups, benchmark, deterministic, allowTf32)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolutionBackwardWeight(weightSize []int64, gradOutput *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, allowTf32 bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolutionBackwardWeight(weightSize, gradOutput, padding, stride, dilation, groups, benchmark, deterministic, allowTf32, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolutionTranspose(weight *Tensor, padding []int64, outputPadding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolutionTranspose(weight, padding, outputPadding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolutionTranspose1(weight *Tensor, bias *Tensor, padding []int64, outputPadding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolutionTranspose1(weight, bias, padding, outputPadding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolutionTranspose2(weight *Tensor, padding []int64, outputPadding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, allowTf32 bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolutionTranspose2(weight, padding, outputPadding, stride, dilation, groups, benchmark, deterministic, allowTf32, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCudnnConvolutionTransposeBackwardInput(gradOutput *Tensor, weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, allowTf32 bool)(retVal *Tensor) { 
  
  retVal, err := CudnnConvolutionTransposeBackwardInput(gradOutput, weight, padding, stride, dilation, groups, benchmark, deterministic, allowTf32)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnConvolutionTransposeBackwardWeight(weightSize []int64, gradOutput *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, allowTf32 bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnConvolutionTransposeBackwardWeight(weightSize, gradOutput, padding, stride, dilation, groups, benchmark, deterministic, allowTf32, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCudnnGridSampler(grid *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CudnnGridSampler(grid, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCummaxminBackward(grad *Tensor, input *Tensor, indices *Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := CummaxminBackward(grad, input, indices, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCumprod(dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Cumprod(dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustCumprodBackward(grad *Tensor, input *Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := CumprodBackward(grad, input, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCumprodOut(out *Tensor, dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CumprodOut(out, dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCumsum(dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Cumsum(dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustCumsumOut(out *Tensor, dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.CumsumOut(out, dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustData(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Data(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDeg2rad(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Deg2rad(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDeg2rad_()() { 
  
  err := ts.Deg2rad_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustDeg2radOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Deg2radOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDequantize(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Dequantize(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDet(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Det(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDetach(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Detach(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDetach_()() { 
  
  err := ts.Detach_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustDiag(diagonal int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Diag(diagonal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustDiagBackward(grad *Tensor, inputSizes []int64, diagonal int64)(retVal *Tensor) { 
  
  retVal, err := DiagBackward(grad, inputSizes, diagonal)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDiagEmbed(offset int64, dim1 int64, dim2 int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.DiagEmbed(offset, dim1, dim2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDiagOut(out *Tensor, diagonal int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.DiagOut(out, diagonal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDiagflat(offset int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Diagflat(offset, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDiagonal(offset int64, dim1 int64, dim2 int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Diagonal(offset, dim1, dim2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustDiagonalBackward(grad *Tensor, inputSizes []int64, offset int64, dim1 int64, dim2 int64)(retVal *Tensor) { 
  
  retVal, err := DiagonalBackward(grad, inputSizes, offset, dim1, dim2)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDigamma(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Digamma(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDigamma_()() { 
  
  err := ts.Digamma_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustDigammaOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.DigammaOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDist(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Dist(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDiv(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Div(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDiv1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Div1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDiv_(other *Tensor)() { 
  
  err := ts.Div_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustDiv1_(other *Scalar)() { 
  
  err := ts.Div1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustDivOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.DivOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDivide(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Divide(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDivide1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Divide1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDivide_(other *Tensor)() { 
  
  err := ts.Divide_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustDivide1_(other *Scalar)() { 
  
  err := ts.Divide1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustDivideOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.DivideOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDot(tensor *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Dot(tensor, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDotOut(out *Tensor, tensor *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.DotOut(out, tensor, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustDropout(input *Tensor, p float64, train bool)(retVal *Tensor) { 
  
  retVal, err := Dropout(input, p, train)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustDropout_(p float64, train bool)() { 
  
  err := ts.Dropout_(p, train)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustDstack(tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := Dstack(tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustDstackOut(out *Tensor, tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := DstackOut(out, tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEinsum(equation string, tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := Einsum(equation, tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustElu(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Elu(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustElu_()() { 
  
  err := ts.Elu_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustEluBackward(gradOutput *Tensor, alpha *Scalar, scale *Scalar, inputScale *Scalar, output *Tensor)(retVal *Tensor) { 
  
  retVal, err := EluBackward(gradOutput, alpha, scale, inputScale, output)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEluBackwardOut(gradInput *Tensor, gradOutput *Tensor, alpha *Scalar, scale *Scalar, inputScale *Scalar, output *Tensor)(retVal *Tensor) { 
  
  retVal, err := EluBackwardOut(gradInput, gradOutput, alpha, scale, inputScale, output)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustEluOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.EluOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmbedding(weight *Tensor, indices *Tensor, paddingIdx int64, scaleGradByFreq bool, sparse bool)(retVal *Tensor) { 
  
  retVal, err := Embedding(weight, indices, paddingIdx, scaleGradByFreq, sparse)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmbeddingBackward(grad *Tensor, indices *Tensor, numWeights int64, paddingIdx int64, scaleGradByFreq bool, sparse bool)(retVal *Tensor) { 
  
  retVal, err := EmbeddingBackward(grad, indices, numWeights, paddingIdx, scaleGradByFreq, sparse)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmbeddingDenseBackward(gradOutput *Tensor, indices *Tensor, numWeights int64, paddingIdx int64, scaleGradByFreq bool)(retVal *Tensor) { 
  
  retVal, err := EmbeddingDenseBackward(gradOutput, indices, numWeights, paddingIdx, scaleGradByFreq)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustEmbeddingRenorm_(indices *Tensor, maxNorm float64, normType float64)() { 
  
  err := ts.EmbeddingRenorm_(indices, maxNorm, normType)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustEmbeddingSparseBackward(grad *Tensor, indices *Tensor, numWeights int64, paddingIdx int64, scaleGradByFreq bool)(retVal *Tensor) { 
  
  retVal, err := EmbeddingSparseBackward(grad, indices, numWeights, paddingIdx, scaleGradByFreq)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmpty(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Empty(size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustEmptyLike(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.EmptyLike(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmptyMeta(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := EmptyMeta(size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmptyOut(out *Tensor, size []int64)(retVal *Tensor) { 
  
  retVal, err := EmptyOut(out, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmptyQuantized(size []int64, qtensor *Tensor)(retVal *Tensor) { 
  
  retVal, err := EmptyQuantized(size, qtensor)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEmptyStrided(size []int64, stride []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := EmptyStrided(size, stride, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustEq(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Eq(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustEq1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Eq1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustEq_(other *Scalar)() { 
  
  err := ts.Eq_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustEq1_(other *Tensor)() { 
  
  err := ts.Eq1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustEqOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.EqOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustEqOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.EqOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustErf(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Erf(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustErf_()() { 
  
  err := ts.Erf_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustErfOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ErfOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustErfc(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Erfc(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustErfc_()() { 
  
  err := ts.Erfc_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustErfcOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ErfcOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustErfinv(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Erfinv(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustErfinv_()() { 
  
  err := ts.Erfinv_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustErfinvOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ErfinvOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExp(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Exp(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExp2(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Exp2(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExp2_()() { 
  
  err := ts.Exp2_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustExp2Out(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Exp2Out(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExp_()() { 
  
  err := ts.Exp_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustExpOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ExpOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExpand(size []int64, implicit bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Expand(size, implicit, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExpandAs(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ExpandAs(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExpm1(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Expm1(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExpm1_()() { 
  
  err := ts.Expm1_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustExpm1Out(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Expm1Out(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustExponential_(lambd float64)() { 
  
  err := ts.Exponential_(lambd)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustEye(n int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Eye(n, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEye1(n int64, m int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Eye1(n, m, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEyeOut(out *Tensor, n int64)(retVal *Tensor) { 
  
  retVal, err := EyeOut(out, n)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustEyeOut1(out *Tensor, n int64, m int64)(retVal *Tensor) { 
  
  retVal, err := EyeOut1(out, n, m)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFakeQuantizePerChannelAffine(scale *Tensor, zeroPoint *Tensor, axis int64, quantMin int64, quantMax int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FakeQuantizePerChannelAffine(scale, zeroPoint, axis, quantMin, quantMax, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFakeQuantizePerChannelAffineBackward(grad *Tensor, scale *Tensor, zeroPoint *Tensor, axis int64, quantMin int64, quantMax int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FakeQuantizePerChannelAffineBackward(grad, scale, zeroPoint, axis, quantMin, quantMax, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFakeQuantizePerTensorAffine(scale float64, zeroPoint int64, quantMin int64, quantMax int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FakeQuantizePerTensorAffine(scale, zeroPoint, quantMin, quantMax, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFakeQuantizePerTensorAffineBackward(grad *Tensor, scale float64, zeroPoint int64, quantMin int64, quantMax int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FakeQuantizePerTensorAffineBackward(grad, scale, zeroPoint, quantMin, quantMax, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFbgemmLinearFp16Weight(input *Tensor, packedWeight *Tensor, bias *Tensor)(retVal *Tensor) { 
  
  retVal, err := FbgemmLinearFp16Weight(input, packedWeight, bias)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFbgemmLinearFp16WeightFp32Activation(input *Tensor, packedWeight *Tensor, bias *Tensor)(retVal *Tensor) { 
  
  retVal, err := FbgemmLinearFp16WeightFp32Activation(input, packedWeight, bias)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFbgemmLinearInt8Weight(input *Tensor, weight *Tensor, packed *Tensor, colOffsets *Tensor, weightScale *Scalar, weightZeroPoint *Scalar, bias *Tensor)(retVal *Tensor) { 
  
  retVal, err := FbgemmLinearInt8Weight(input, weight, packed, colOffsets, weightScale, weightZeroPoint, bias)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFbgemmLinearInt8WeightFp32Activation(input *Tensor, weight *Tensor, packed *Tensor, colOffsets *Tensor, weightScale *Scalar, weightZeroPoint *Scalar, bias *Tensor)(retVal *Tensor) { 
  
  retVal, err := FbgemmLinearInt8WeightFp32Activation(input, weight, packed, colOffsets, weightScale, weightZeroPoint, bias)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFbgemmPackGemmMatrixFp16(input *Tensor)(retVal *Tensor) { 
  
  retVal, err := FbgemmPackGemmMatrixFp16(input)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFbgemmPackQuantizedMatrix(input *Tensor)(retVal *Tensor) { 
  
  retVal, err := FbgemmPackQuantizedMatrix(input)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFbgemmPackQuantizedMatrix1(input *Tensor, k int64, n int64)(retVal *Tensor) { 
  
  retVal, err := FbgemmPackQuantizedMatrix1(input, k, n)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFeatureAlphaDropout(input *Tensor, p float64, train bool)(retVal *Tensor) { 
  
  retVal, err := FeatureAlphaDropout(input, p, train)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFeatureAlphaDropout_(p float64, train bool)() { 
  
  err := ts.FeatureAlphaDropout_(p, train)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustFeatureDropout(input *Tensor, p float64, train bool)(retVal *Tensor) { 
  
  retVal, err := FeatureDropout(input, p, train)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFeatureDropout_(p float64, train bool)() { 
  
  err := ts.FeatureDropout_(p, train)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFft(signalNdim int64, normalized bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Fft(signalNdim, normalized, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftFft(n []int64, dim int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftFft(n, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftFftn(s []int64, dim []int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftFftn(s, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftHfft(n []int64, dim int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftHfft(n, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftIfft(n []int64, dim int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftIfft(n, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftIfftn(s []int64, dim []int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftIfftn(s, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftIhfft(n []int64, dim int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftIhfft(n, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftIrfft(n []int64, dim int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftIrfft(n, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftIrfftn(s []int64, dim []int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftIrfftn(s, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftRfft(n []int64, dim int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftRfft(n, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFftRfftn(s []int64, dim []int64, norm string, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FftRfftn(s, dim, norm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFill_(value *Scalar)() { 
  
  err := ts.Fill_(value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFill1_(value *Tensor)() { 
  
  err := ts.Fill1_(value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFillDiagonal_(fillValue *Scalar, wrap bool)() { 
  
  err := ts.FillDiagonal_(fillValue, wrap)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFix(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Fix(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFix_()() { 
  
  err := ts.Fix_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFixOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FixOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFlatten(startDim int64, endDim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Flatten(startDim, endDim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFlip(dims []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Flip(dims, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFliplr(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Fliplr(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFlipud(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Flipud(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFloor(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Floor(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFloor_()() { 
  
  err := ts.Floor_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFloorDivide(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FloorDivide(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFloorDivide1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FloorDivide1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFloorDivide_(other *Tensor)() { 
  
  err := ts.FloorDivide_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFloorDivide1_(other *Scalar)() { 
  
  err := ts.FloorDivide1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFloorDivideOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FloorDivideOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFloorOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FloorOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFmod(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Fmod(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFmod1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Fmod1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFmod_(other *Scalar)() { 
  
  err := ts.Fmod_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFmod1_(other *Tensor)() { 
  
  err := ts.Fmod1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFmodOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FmodOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFmodOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FmodOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFrac(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Frac(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFrac_()() { 
  
  err := ts.Frac_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustFracOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FracOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFractionalMaxPool2dBackward(gradOutput *Tensor, kernelSize []int64, outputSize []int64, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FractionalMaxPool2dBackward(gradOutput, kernelSize, outputSize, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFractionalMaxPool2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, kernelSize []int64, outputSize []int64, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FractionalMaxPool2dBackwardOut(gradInput, gradOutput, kernelSize, outputSize, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFractionalMaxPool3dBackward(gradOutput *Tensor, kernelSize []int64, outputSize []int64, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FractionalMaxPool3dBackward(gradOutput, kernelSize, outputSize, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFractionalMaxPool3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, kernelSize []int64, outputSize []int64, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FractionalMaxPool3dBackwardOut(gradInput, gradOutput, kernelSize, outputSize, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFrobeniusNorm(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FrobeniusNorm(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFrobeniusNorm1(dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FrobeniusNorm1(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFrobeniusNormOut(out *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FrobeniusNormOut(out, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFromFile(filename string, shared bool, size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := FromFile(filename, shared, size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFull(size []int64, fillValue *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Full(size, fillValue, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustFullLike(fillValue *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.FullLike(fillValue, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustFullOut(out *Tensor, size []int64, fillValue *Scalar)(retVal *Tensor) { 
  
  retVal, err := FullOut(out, size, fillValue)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGather(dim int64, index *Tensor, sparseGrad bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Gather(dim, index, sparseGrad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGatherBackward(grad *Tensor, dim int64, index *Tensor, sparseGrad bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GatherBackward(grad, dim, index, sparseGrad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGatherOut(out *Tensor, dim int64, index *Tensor, sparseGrad bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GatherOut(out, dim, index, sparseGrad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGcd(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Gcd(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGcd_(other *Tensor)() { 
  
  err := ts.Gcd_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGcdOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GcdOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGe(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ge(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGe1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ge1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGe_(other *Scalar)() { 
  
  err := ts.Ge_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGe1_(other *Tensor)() { 
  
  err := ts.Ge1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGeOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GeOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGeOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GeOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGelu(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Gelu(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGeluBackward(grad *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GeluBackward(grad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGeometric_(p float64)() { 
  
  err := ts.Geometric_(p)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGer(vec2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ger(vec2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGerOut(out *Tensor, vec2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GerOut(out, vec2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGlu(dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Glu(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGluBackward(gradOutput *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GluBackward(gradOutput, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGluBackwardOut(gradInput *Tensor, gradOutput *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GluBackwardOut(gradInput, gradOutput, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGluOut(out *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GluOut(out, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGrad(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Grad(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreater(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Greater(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreater1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Greater1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreater_(other *Scalar)() { 
  
  err := ts.Greater_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGreater1_(other *Tensor)() { 
  
  err := ts.Greater1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGreaterEqual(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GreaterEqual(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreaterEqual1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GreaterEqual1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreaterEqual_(other *Scalar)() { 
  
  err := ts.GreaterEqual_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGreaterEqual1_(other *Tensor)() { 
  
  err := ts.GreaterEqual1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGreaterEqualOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GreaterEqualOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreaterEqualOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GreaterEqualOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreaterOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GreaterOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGreaterOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GreaterOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustGridSampler(input *Tensor, grid *Tensor, interpolationMode int64, paddingMode int64, alignCorners bool)(retVal *Tensor) { 
  
  retVal, err := GridSampler(input, grid, interpolationMode, paddingMode, alignCorners)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustGridSampler2d(input *Tensor, grid *Tensor, interpolationMode int64, paddingMode int64, alignCorners bool)(retVal *Tensor) { 
  
  retVal, err := GridSampler2d(input, grid, interpolationMode, paddingMode, alignCorners)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustGridSampler3d(input *Tensor, grid *Tensor, interpolationMode int64, paddingMode int64, alignCorners bool)(retVal *Tensor) { 
  
  retVal, err := GridSampler3d(input, grid, interpolationMode, paddingMode, alignCorners)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustGroupNorm(input *Tensor, numGroups int64, weight *Tensor, bias *Tensor, eps float64, cudnnEnabled bool)(retVal *Tensor) { 
  
  retVal, err := GroupNorm(input, numGroups, weight, bias, eps, cudnnEnabled)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustGruCell(input *Tensor, hx *Tensor, wIh *Tensor, wHh *Tensor, bIh *Tensor, bHh *Tensor)(retVal *Tensor) { 
  
  retVal, err := GruCell(input, hx, wIh, wHh, bIh, bHh)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGt(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Gt(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGt1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Gt1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGt_(other *Scalar)() { 
  
  err := ts.Gt_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGt1_(other *Tensor)() { 
  
  err := ts.Gt1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustGtOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GtOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustGtOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.GtOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHammingWindow(windowLength int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := HammingWindow(windowLength, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHammingWindow1(windowLength int64, periodic bool, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := HammingWindow1(windowLength, periodic, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHammingWindow2(windowLength int64, periodic bool, alpha float64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := HammingWindow2(windowLength, periodic, alpha, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHammingWindow3(windowLength int64, periodic bool, alpha float64, beta float64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := HammingWindow3(windowLength, periodic, alpha, beta, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHannWindow(windowLength int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := HannWindow(windowLength, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHannWindow1(windowLength int64, periodic bool, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := HannWindow1(windowLength, periodic, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardshrink(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Hardshrink(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardshrinkBackward(gradOut *Tensor, lambd *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardshrinkBackward(gradOut, lambd, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardsigmoid(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Hardsigmoid(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardsigmoid_()() { 
  
  err := ts.Hardsigmoid_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustHardsigmoidBackward(gradOutput *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardsigmoidBackward(gradOutput, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardsigmoidOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardsigmoidOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardswish(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Hardswish(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardswish_()() { 
  
  err := ts.Hardswish_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustHardswishBackward(gradOutput *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardswishBackward(gradOutput, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardswishOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardswishOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardtanh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Hardtanh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardtanh_()() { 
  
  err := ts.Hardtanh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustHardtanhBackward(gradOutput *Tensor, minVal *Scalar, maxVal *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardtanhBackward(gradOutput, minVal, maxVal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardtanhBackwardOut(gradInput *Tensor, gradOutput *Tensor, minVal *Scalar, maxVal *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardtanhBackwardOut(gradInput, gradOutput, minVal, maxVal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHardtanhOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HardtanhOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHeaviside(values *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Heaviside(values, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHeaviside_(values *Tensor)() { 
  
  err := ts.Heaviside_(values)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustHeavisideOut(out *Tensor, values *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HeavisideOut(out, values, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHingeEmbeddingLoss(target *Tensor, margin float64, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HingeEmbeddingLoss(target, margin, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHistc(bins int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Histc(bins, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHistcOut(out *Tensor, bins int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HistcOut(out, bins, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHspmm(mat1 *Tensor, mat2 *Tensor)(retVal *Tensor) { 
  
  retVal, err := Hspmm(mat1, mat2)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHspmmOut(out *Tensor, mat1 *Tensor, mat2 *Tensor)(retVal *Tensor) { 
  
  retVal, err := HspmmOut(out, mat1, mat2)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHstack(tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := Hstack(tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustHstackOut(out *Tensor, tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := HstackOut(out, tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHypot(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Hypot(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustHypot_(other *Tensor)() { 
  
  err := ts.Hypot_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustHypotOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.HypotOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustI0(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.I0(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustI0_()() { 
  
  err := ts.I0_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustI0Out(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.I0Out(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIfft(signalNdim int64, normalized bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ifft(signalNdim, normalized, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIm2col(kernelSize []int64, dilation []int64, padding []int64, stride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Im2col(kernelSize, dilation, padding, stride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustIm2colBackward(gradOutput *Tensor, inputSize []int64, kernelSize []int64, dilation []int64, padding []int64, stride []int64)(retVal *Tensor) { 
  
  retVal, err := Im2colBackward(gradOutput, inputSize, kernelSize, dilation, padding, stride)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustIm2colBackwardOut(gradInput *Tensor, gradOutput *Tensor, inputSize []int64, kernelSize []int64, dilation []int64, padding []int64, stride []int64)(retVal *Tensor) { 
  
  retVal, err := Im2colBackwardOut(gradInput, gradOutput, inputSize, kernelSize, dilation, padding, stride)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIm2colOut(out *Tensor, kernelSize []int64, dilation []int64, padding []int64, stride []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Im2colOut(out, kernelSize, dilation, padding, stride, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustImag(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Imag(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndex(indices []Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Index(indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndexAdd(dim int64, index *Tensor, source *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IndexAdd(dim, index, source, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndexAdd_(dim int64, index *Tensor, source *Tensor)() { 
  
  err := ts.IndexAdd_(dim, index, source)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustIndexCopy(dim int64, index *Tensor, source *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IndexCopy(dim, index, source, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndexCopy_(dim int64, index *Tensor, source *Tensor)() { 
  
  err := ts.IndexCopy_(dim, index, source)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustIndexFill(dim int64, index *Tensor, value *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IndexFill(dim, index, value, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndexFill1(dim int64, index *Tensor, value *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IndexFill1(dim, index, value, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndexFill_(dim int64, index *Tensor, value *Scalar)() { 
  
  err := ts.IndexFill_(dim, index, value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustIndexFill1_(dim int64, index *Tensor, value *Tensor)() { 
  
  err := ts.IndexFill1_(dim, index, value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustIndexPut(indices []Tensor, values *Tensor, accumulate bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IndexPut(indices, values, accumulate, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndexPut_(indices []Tensor, values *Tensor, accumulate bool)() { 
  
  err := ts.IndexPut_(indices, values, accumulate)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustIndexSelect(dim int64, index *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IndexSelect(dim, index, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustIndexSelectBackward(grad *Tensor, selfSizes []int64, dim int64, index *Tensor)(retVal *Tensor) { 
  
  retVal, err := IndexSelectBackward(grad, selfSizes, dim, index)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndexSelectOut(out *Tensor, dim int64, index *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IndexSelectOut(out, dim, index, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIndices(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Indices(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustInfinitelyDifferentiableGeluBackward(grad *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.InfinitelyDifferentiableGeluBackward(grad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustInstanceNorm(input *Tensor, weight *Tensor, bias *Tensor, runningMean *Tensor, runningVar *Tensor, useInputStats bool, momentum float64, eps float64, cudnnEnabled bool)(retVal *Tensor) { 
  
  retVal, err := InstanceNorm(input, weight, bias, runningMean, runningVar, useInputStats, momentum, eps, cudnnEnabled)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIntRepr(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IntRepr(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustInverse(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Inverse(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustInverseOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.InverseOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIrfft(signalNdim int64, normalized bool, onesided bool, signalSizes []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Irfft(signalNdim, normalized, onesided, signalSizes, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsclose(other *Tensor, rtol float64, atol float64, equalNan bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Isclose(other, rtol, atol, equalNan, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsfinite(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Isfinite(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsinf(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Isinf(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsnan(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Isnan(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsneginf(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Isneginf(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsneginfOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IsneginfOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsposinf(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Isposinf(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsposinfOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.IsposinfOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIsreal(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Isreal(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustIstft(nFft int64, hopLength []int64, winLength []int64, window *Tensor, center bool, normalized bool, onesided bool, length []int64, returnComplex bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Istft(nFft, hopLength, winLength, window, center, normalized, onesided, length, returnComplex, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustKaiserWindow(windowLength int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := KaiserWindow(windowLength, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustKaiserWindow1(windowLength int64, periodic bool, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := KaiserWindow1(windowLength, periodic, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustKaiserWindow2(windowLength int64, periodic bool, beta float64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := KaiserWindow2(windowLength, periodic, beta, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustKlDiv(target *Tensor, reduction int64, logTarget bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.KlDiv(target, reduction, logTarget, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustKlDivBackward(gradOutput *Tensor, target *Tensor, reduction int64, logTarget bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.KlDivBackward(gradOutput, target, reduction, logTarget, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustL1Loss(target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.L1Loss(target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustL1LossBackward(gradOutput *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.L1LossBackward(gradOutput, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustL1LossBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.L1LossBackwardOut(gradInput, gradOutput, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustL1LossOut(out *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.L1LossOut(out, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustLayerNorm(input *Tensor, normalizedShape []int64, weight *Tensor, bias *Tensor, eps float64, cudnnEnable bool)(retVal *Tensor) { 
  
  retVal, err := LayerNorm(input, normalizedShape, weight, bias, eps, cudnnEnable)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLcm(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Lcm(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLcm_(other *Tensor)() { 
  
  err := ts.Lcm_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLcmOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LcmOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLe(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Le(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLe1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Le1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLe_(other *Scalar)() { 
  
  err := ts.Le_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLe1_(other *Tensor)() { 
  
  err := ts.Le1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLeOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LeOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLeOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LeOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLeakyRelu(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LeakyRelu(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLeakyRelu_()() { 
  
  err := ts.LeakyRelu_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLeakyReluBackward(gradOutput *Tensor, negativeSlope *Scalar, selfIsResult bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LeakyReluBackward(gradOutput, negativeSlope, selfIsResult, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLeakyReluOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LeakyReluOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLerp(end *Tensor, weight *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Lerp(end, weight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLerp1(end *Tensor, weight *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Lerp1(end, weight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLerp_(end *Tensor, weight *Scalar)() { 
  
  err := ts.Lerp_(end, weight)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLerp1_(end *Tensor, weight *Tensor)() { 
  
  err := ts.Lerp1_(end, weight)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLerpOut(out *Tensor, end *Tensor, weight *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LerpOut(out, end, weight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLerpOut1(out *Tensor, end *Tensor, weight *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LerpOut1(out, end, weight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLess(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Less(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLess1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Less1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLess_(other *Scalar)() { 
  
  err := ts.Less_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLess1_(other *Tensor)() { 
  
  err := ts.Less1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLessEqual(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LessEqual(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLessEqual1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LessEqual1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLessEqual_(other *Scalar)() { 
  
  err := ts.LessEqual_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLessEqual1_(other *Tensor)() { 
  
  err := ts.LessEqual1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLessEqualOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LessEqualOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLessEqualOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LessEqualOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLessOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LessOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLessOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LessOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLgamma(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Lgamma(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLgamma_()() { 
  
  err := ts.Lgamma_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLgammaOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LgammaOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLinalgDet(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LinalgDet(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLinalgNorm(ord *Scalar, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LinalgNorm(ord, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLinalgNorm1(ord string, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LinalgNorm1(ord, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLinalgNormOut(out *Tensor, ord *Scalar, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LinalgNormOut(out, ord, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLinalgNormOut1(out *Tensor, ord string, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LinalgNormOut1(out, ord, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustLinear(input *Tensor, weight *Tensor, bias *Tensor)(retVal *Tensor) { 
  
  retVal, err := Linear(input, weight, bias)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustLinspace(start *Scalar, end *Scalar, steps []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Linspace(start, end, steps, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustLinspaceOut(out *Tensor, start *Scalar, end *Scalar, steps []int64)(retVal *Tensor) { 
  
  retVal, err := LinspaceOut(out, start, end, steps)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Log(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog10(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Log10(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog10_()() { 
  
  err := ts.Log10_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLog10Out(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Log10Out(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog1p(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Log1p(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog1p_()() { 
  
  err := ts.Log1p_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLog1pOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Log1pOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog2(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Log2(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog2_()() { 
  
  err := ts.Log2_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLog2Out(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Log2Out(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLog_()() { 
  
  err := ts.Log_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLogNormal_(mean float64, std float64)() { 
  
  err := ts.LogNormal_(mean, std)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLogOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogSigmoid(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogSigmoid(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogSigmoidBackward(gradOutput *Tensor, buffer *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogSigmoidBackward(gradOutput, buffer, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogSigmoidBackwardOut(gradInput *Tensor, gradOutput *Tensor, buffer *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogSigmoidBackwardOut(gradInput, gradOutput, buffer, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogSigmoidOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogSigmoidOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogSoftmax(dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogSoftmax(dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogaddexp(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Logaddexp(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogaddexp2(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Logaddexp2(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogaddexp2Out(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Logaddexp2Out(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogaddexpOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogaddexpOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogcumsumexp(dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Logcumsumexp(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogcumsumexpOut(out *Tensor, dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogcumsumexpOut(out, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogdet(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Logdet(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalAnd(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalAnd(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalAnd_(other *Tensor)() { 
  
  err := ts.LogicalAnd_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLogicalAndOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalAndOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalNot(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalNot(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalNot_()() { 
  
  err := ts.LogicalNot_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLogicalNotOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalNotOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalOr(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalOr(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalOr_(other *Tensor)() { 
  
  err := ts.LogicalOr_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLogicalOrOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalOrOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalXor(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalXor(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogicalXor_(other *Tensor)() { 
  
  err := ts.LogicalXor_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLogicalXorOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogicalXorOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogit(eps []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Logit(eps, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogit_(eps []float64)() { 
  
  err := ts.Logit_(eps)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLogitBackward(gradOutput *Tensor, eps []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogitBackward(gradOutput, eps, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogitBackwardOut(gradInput *Tensor, gradOutput *Tensor, eps []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogitBackwardOut(gradInput, gradOutput, eps, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogitOut(out *Tensor, eps []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogitOut(out, eps, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustLogspace(start *Scalar, end *Scalar, steps []int64, base float64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Logspace(start, end, steps, base, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustLogspaceOut(out *Tensor, start *Scalar, end *Scalar, steps []int64, base float64)(retVal *Tensor) { 
  
  retVal, err := LogspaceOut(out, start, end, steps, base)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogsumexp(dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Logsumexp(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLogsumexpOut(out *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LogsumexpOut(out, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLt(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Lt(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLt1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Lt1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLt_(other *Scalar)() { 
  
  err := ts.Lt_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLt1_(other *Tensor)() { 
  
  err := ts.Lt1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustLtOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LtOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLtOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LtOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLuSolve(lUData *Tensor, lUPivots *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LuSolve(lUData, lUPivots, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustLuSolveOut(out *Tensor, lUData *Tensor, lUPivots *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.LuSolveOut(out, lUData, lUPivots, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMarginRankingLoss(input1 *Tensor, input2 *Tensor, target *Tensor, margin float64, reduction int64)(retVal *Tensor) { 
  
  retVal, err := MarginRankingLoss(input1, input2, target, margin, reduction)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaskedFill(mask *Tensor, value *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaskedFill(mask, value, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaskedFill1(mask *Tensor, value *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaskedFill1(mask, value, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaskedFill_(mask *Tensor, value *Scalar)() { 
  
  err := ts.MaskedFill_(mask, value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustMaskedFill1_(mask *Tensor, value *Tensor)() { 
  
  err := ts.MaskedFill1_(mask, value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustMaskedScatter(mask *Tensor, source *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaskedScatter(mask, source, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaskedScatter_(mask *Tensor, source *Tensor)() { 
  
  err := ts.MaskedScatter_(mask, source)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustMaskedSelect(mask *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaskedSelect(mask, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMaskedSelectBackward(grad *Tensor, input *Tensor, mask *Tensor)(retVal *Tensor) { 
  
  retVal, err := MaskedSelectBackward(grad, input, mask)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaskedSelectOut(out *Tensor, mask *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaskedSelectOut(out, mask, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMatmul(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Matmul(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMatmulOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MatmulOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMatrixExp(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MatrixExp(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMatrixExpBackward(grad *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MatrixExpBackward(grad, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMatrixPower(n int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MatrixPower(n, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMatrixRank(symmetric bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MatrixRank(symmetric, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMatrixRank1(tol float64, symmetric bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MatrixRank1(tol, symmetric, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMax(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Max(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMax1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Max1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxPool1d(kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxPool1d(kernelSize, stride, padding, dilation, ceilMode, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxPool2d(kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxPool2d(kernelSize, stride, padding, dilation, ceilMode, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxPool2dWithIndicesBackward(gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxPool2dWithIndicesBackward(gradOutput, kernelSize, stride, padding, dilation, ceilMode, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxPool2dWithIndicesBackwardOut(gradInput *Tensor, gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxPool2dWithIndicesBackwardOut(gradInput, gradOutput, kernelSize, stride, padding, dilation, ceilMode, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxPool3d(kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxPool3d(kernelSize, stride, padding, dilation, ceilMode, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxPool3dWithIndicesBackward(gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxPool3dWithIndicesBackward(gradOutput, kernelSize, stride, padding, dilation, ceilMode, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxPool3dWithIndicesBackwardOut(gradInput *Tensor, gradOutput *Tensor, kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, indices *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxPool3dWithIndicesBackwardOut(gradInput, gradOutput, kernelSize, stride, padding, dilation, ceilMode, indices, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool2d(indices *Tensor, outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool2d(indices, outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool2dBackward(gradOutput *Tensor, indices *Tensor, outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool2dBackward(gradOutput, indices, outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, indices *Tensor, outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool2dBackwardOut(gradInput, gradOutput, indices, outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool2dOut(out *Tensor, indices *Tensor, outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool2dOut(out, indices, outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool3d(indices *Tensor, outputSize []int64, stride []int64, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool3d(indices, outputSize, stride, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool3dBackward(gradOutput *Tensor, indices *Tensor, outputSize []int64, stride []int64, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool3dBackward(gradOutput, indices, outputSize, stride, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, indices *Tensor, outputSize []int64, stride []int64, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool3dBackwardOut(gradInput, gradOutput, indices, outputSize, stride, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaxUnpool3dOut(out *Tensor, indices *Tensor, outputSize []int64, stride []int64, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaxUnpool3dOut(out, indices, outputSize, stride, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaximum(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Maximum(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMaximumOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MaximumOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMean(dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Mean(dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMean1(dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Mean1(dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMeanOut(out *Tensor, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MeanOut(out, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMedian(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Median(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMin(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Min(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMin1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Min1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMinOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MinOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMinimum(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Minimum(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMinimumOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MinimumOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMiopenConvolution(weight *Tensor, bias *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MiopenConvolution(weight, bias, padding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMiopenConvolutionBackwardBias(gradOutput *Tensor)(retVal *Tensor) { 
  
  retVal, err := MiopenConvolutionBackwardBias(gradOutput)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMiopenConvolutionBackwardInput(selfSize []int64, gradOutput *Tensor, weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(retVal *Tensor) { 
  
  retVal, err := MiopenConvolutionBackwardInput(selfSize, gradOutput, weight, padding, stride, dilation, groups, benchmark, deterministic)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMiopenConvolutionBackwardWeight(weightSize []int64, gradOutput *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MiopenConvolutionBackwardWeight(weightSize, gradOutput, padding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMiopenConvolutionTranspose(weight *Tensor, bias *Tensor, padding []int64, outputPadding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MiopenConvolutionTranspose(weight, bias, padding, outputPadding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMiopenConvolutionTransposeBackwardInput(gradOutput *Tensor, weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(retVal *Tensor) { 
  
  retVal, err := MiopenConvolutionTransposeBackwardInput(gradOutput, weight, padding, stride, dilation, groups, benchmark, deterministic)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMiopenConvolutionTransposeBackwardWeight(weightSize []int64, gradOutput *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MiopenConvolutionTransposeBackwardWeight(weightSize, gradOutput, padding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMiopenDepthwiseConvolution(weight *Tensor, bias *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MiopenDepthwiseConvolution(weight, bias, padding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMiopenDepthwiseConvolutionBackwardInput(selfSize []int64, gradOutput *Tensor, weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(retVal *Tensor) { 
  
  retVal, err := MiopenDepthwiseConvolutionBackwardInput(selfSize, gradOutput, weight, padding, stride, dilation, groups, benchmark, deterministic)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMiopenDepthwiseConvolutionBackwardWeight(weightSize []int64, gradOutput *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MiopenDepthwiseConvolutionBackwardWeight(weightSize, gradOutput, padding, stride, dilation, groups, benchmark, deterministic, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMkldnnAdaptiveAvgPool2d(outputSize []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MkldnnAdaptiveAvgPool2d(outputSize, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMkldnnConvolution(weight *Tensor, bias *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MkldnnConvolution(weight, bias, padding, stride, dilation, groups, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMkldnnConvolutionBackwardInput(selfSize []int64, gradOutput *Tensor, weight *Tensor, padding []int64, stride []int64, dilation []int64, groups int64, biasDefined bool)(retVal *Tensor) { 
  
  retVal, err := MkldnnConvolutionBackwardInput(selfSize, gradOutput, weight, padding, stride, dilation, groups, biasDefined)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustMkldnnLinear(input *Tensor, weight *Tensor, bias *Tensor)(retVal *Tensor) { 
  
  retVal, err := MkldnnLinear(input, weight, bias)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMkldnnMaxPool2d(kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MkldnnMaxPool2d(kernelSize, stride, padding, dilation, ceilMode, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMkldnnMaxPool3d(kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MkldnnMaxPool3d(kernelSize, stride, padding, dilation, ceilMode, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMkldnnReorderConv2dWeight(padding []int64, stride []int64, dilation []int64, groups int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MkldnnReorderConv2dWeight(padding, stride, dilation, groups, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMkldnnReorderConv3dWeight(padding []int64, stride []int64, dilation []int64, groups int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MkldnnReorderConv3dWeight(padding, stride, dilation, groups, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMm(mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Mm(mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMmOut(out *Tensor, mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MmOut(out, mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMovedim(source []int64, destination []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Movedim(source, destination, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMovedim1(source int64, destination int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Movedim1(source, destination, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMseLoss(target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MseLoss(target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMseLossBackward(gradOutput *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MseLossBackward(gradOutput, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMseLossBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MseLossBackwardOut(gradInput, gradOutput, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMseLossOut(out *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MseLossOut(out, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMul(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Mul(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMul1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Mul1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMul_(other *Tensor)() { 
  
  err := ts.Mul_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustMul1_(other *Scalar)() { 
  
  err := ts.Mul1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustMulOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MulOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultiMarginLossBackward(gradOutput *Tensor, target *Tensor, p *Scalar, margin *Scalar, weight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultiMarginLossBackward(gradOutput, target, p, margin, weight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultiMarginLossBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, p *Scalar, margin *Scalar, weight *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultiMarginLossBackwardOut(gradInput, gradOutput, target, p, margin, weight, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultilabelMarginLoss(target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultilabelMarginLoss(target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultilabelMarginLossBackward(gradOutput *Tensor, target *Tensor, reduction int64, isTarget *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultilabelMarginLossBackward(gradOutput, target, reduction, isTarget, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultilabelMarginLossBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, reduction int64, isTarget *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultilabelMarginLossBackwardOut(gradInput, gradOutput, target, reduction, isTarget, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultilabelMarginLossOut(out *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultilabelMarginLossOut(out, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultinomial(numSamples int64, replacement bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Multinomial(numSamples, replacement, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultinomialOut(out *Tensor, numSamples int64, replacement bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultinomialOut(out, numSamples, replacement, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultiply(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Multiply(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultiply1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Multiply1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMultiply_(other *Tensor)() { 
  
  err := ts.Multiply_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustMultiply1_(other *Scalar)() { 
  
  err := ts.Multiply1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustMultiplyOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MultiplyOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMv(vec *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Mv(vec, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMvOut(out *Tensor, vec *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.MvOut(out, vec, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMvlgamma(p int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Mvlgamma(p, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustMvlgamma_(p int64)() { 
  
  err := ts.Mvlgamma_(p)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNanquantile(q float64, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Nanquantile(q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNanquantile1(q *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Nanquantile1(q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNanquantileOut(out *Tensor, q float64, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NanquantileOut(out, q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNanquantileOut1(out *Tensor, q *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NanquantileOut1(out, q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNansum(dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Nansum(dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNansum1(dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Nansum1(dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNansumOut(out *Tensor, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NansumOut(out, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNarrow(dim int64, start int64, length int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Narrow(dim, start, length, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNarrow1(dim int64, start *Tensor, length int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Narrow1(dim, start, length, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNarrowCopy(dim int64, start int64, length int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NarrowCopy(dim, start, length, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNativeNorm(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NativeNorm(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNativeNorm1(p *Scalar, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NativeNorm1(p, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNe(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ne(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNe1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ne1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNe_(other *Scalar)() { 
  
  err := ts.Ne_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNe1_(other *Tensor)() { 
  
  err := ts.Ne1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNeOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NeOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNeOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NeOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNeg(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Neg(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNeg_()() { 
  
  err := ts.Neg_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNegOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NegOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNegative(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Negative(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNegative_()() { 
  
  err := ts.Negative_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNegativeOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NegativeOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNewEmpty(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NewEmpty(size, optionsKind, optionsDevice, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNewFull(size []int64, fillValue *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NewFull(size, fillValue, optionsKind, optionsDevice, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNewZeros(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NewZeros(size, optionsKind, optionsDevice, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNextafter(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Nextafter(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNextafter_(other *Tensor)() { 
  
  err := ts.Nextafter_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNextafterOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NextafterOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLoss(target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLoss(target, weight, reduction, ignoreIndex, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLoss2d(target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLoss2d(target, weight, reduction, ignoreIndex, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLoss2dBackward(gradOutput *Tensor, target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, totalWeight *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLoss2dBackward(gradOutput, target, weight, reduction, ignoreIndex, totalWeight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLoss2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, totalWeight *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLoss2dBackwardOut(gradInput, gradOutput, target, weight, reduction, ignoreIndex, totalWeight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLoss2dOut(out *Tensor, target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLoss2dOut(out, target, weight, reduction, ignoreIndex, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLossBackward(gradOutput *Tensor, target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, totalWeight *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLossBackward(gradOutput, target, weight, reduction, ignoreIndex, totalWeight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLossBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, totalWeight *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLossBackwardOut(gradInput, gradOutput, target, weight, reduction, ignoreIndex, totalWeight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNllLossOut(out *Tensor, target *Tensor, weight *Tensor, reduction int64, ignoreIndex int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NllLossOut(out, target, weight, reduction, ignoreIndex, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNonzero(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Nonzero(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNonzeroOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NonzeroOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNorm(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Norm(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNorm1(p *Scalar, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Norm1(p, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNorm2(p *Scalar, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Norm2(p, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNorm3(p *Scalar, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Norm3(p, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustNormExceptDim(v *Tensor, pow int64, dim int64)(retVal *Tensor) { 
  
  retVal, err := NormExceptDim(v, pow, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNormOut(out *Tensor, p *Scalar, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NormOut(out, p, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNormOut1(out *Tensor, p *Scalar, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NormOut1(out, p, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNormal_(mean float64, std float64)() { 
  
  err := ts.Normal_(mean, std)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustNormalOut(out *Tensor, mean *Tensor, std float64)(retVal *Tensor) { 
  
  retVal, err := NormalOut(out, mean, std)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustNormalOut1(out *Tensor, mean float64, std *Tensor)(retVal *Tensor) { 
  
  retVal, err := NormalOut1(out, mean, std)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustNormalOut2(out *Tensor, mean *Tensor, std *Tensor)(retVal *Tensor) { 
  
  retVal, err := NormalOut2(out, mean, std)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustNormalOut3(out *Tensor, mean float64, std float64, size []int64)(retVal *Tensor) { 
  
  retVal, err := NormalOut3(out, mean, std, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNotEqual(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NotEqual(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNotEqual1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NotEqual1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNotEqual_(other *Scalar)() { 
  
  err := ts.NotEqual_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNotEqual1_(other *Tensor)() { 
  
  err := ts.NotEqual1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustNotEqualOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NotEqualOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNotEqualOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NotEqualOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNuclearNorm(keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NuclearNorm(keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNuclearNorm1(dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NuclearNorm1(dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNuclearNormOut(out *Tensor, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NuclearNormOut(out, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNuclearNormOut1(out *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NuclearNormOut1(out, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustNumpyT(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.NumpyT(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOneHot(numClasses int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.OneHot(numClasses, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustOnes(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Ones(size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOnesLike(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.OnesLike(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustOnesOut(out *Tensor, size []int64)(retVal *Tensor) { 
  
  retVal, err := OnesOut(out, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOrgqr(input2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Orgqr(input2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOrgqrOut(out *Tensor, input2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.OrgqrOut(out, input2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOrmqr(input2 *Tensor, input3 *Tensor, left bool, transpose bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Ormqr(input2, input3, left, transpose, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOrmqrOut(out *Tensor, input2 *Tensor, input3 *Tensor, left bool, transpose bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.OrmqrOut(out, input2, input3, left, transpose, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOuter(vec2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Outer(vec2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustOuterOut(out *Tensor, vec2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.OuterOut(out, vec2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustPairwiseDistance(x1 *Tensor, x2 *Tensor, p float64, eps float64, keepdim bool)(retVal *Tensor) { 
  
  retVal, err := PairwiseDistance(x1, x2, p, eps, keepdim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPdist(p float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Pdist(p, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPermute(dims []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Permute(dims, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPinMemory(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.PinMemory(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPinverse(rcond float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Pinverse(rcond, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPixelShuffle(upscaleFactor int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.PixelShuffle(upscaleFactor, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPoisson(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Poisson(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustPoissonNllLoss(input *Tensor, target *Tensor, logInput bool, full bool, eps float64, reduction int64)(retVal *Tensor) { 
  
  retVal, err := PoissonNllLoss(input, target, logInput, full, eps, reduction)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustPolar(abs *Tensor, angle *Tensor)(retVal *Tensor) { 
  
  retVal, err := Polar(abs, angle)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustPolarOut(out *Tensor, abs *Tensor, angle *Tensor)(retVal *Tensor) { 
  
  retVal, err := PolarOut(out, abs, angle)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPolygamma(n int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Polygamma(n, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPolygamma_(n int64)() { 
  
  err := ts.Polygamma_(n)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustPolygammaOut(out *Tensor, n int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.PolygammaOut(out, n, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPow(exponent *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Pow(exponent, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPow1(exponent *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Pow1(exponent, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustPow2(selfScalar *Scalar, exponent *Tensor)(retVal *Tensor) { 
  
  retVal, err := Pow2(selfScalar, exponent)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPow_(exponent *Scalar)() { 
  
  err := ts.Pow_(exponent)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustPow1_(exponent *Tensor)() { 
  
  err := ts.Pow1_(exponent)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustPowOut(out *Tensor, exponent *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.PowOut(out, exponent, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPowOut1(out *Tensor, exponent *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.PowOut1(out, exponent, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustPowOut2(out *Tensor, selfScalar *Scalar, exponent *Tensor)(retVal *Tensor) { 
  
  retVal, err := PowOut2(out, selfScalar, exponent)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPrelu(weight *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Prelu(weight, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustProd(dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Prod(dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustProd1(dim int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Prod1(dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustProdOut(out *Tensor, dim int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ProdOut(out, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustPut_(index *Tensor, source *Tensor, accumulate bool)() { 
  
  err := ts.Put_(index, source, accumulate)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustQPerChannelScales(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QPerChannelScales(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQPerChannelZeroPoints(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QPerChannelZeroPoints(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantile(q float64, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Quantile(q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantile1(q *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Quantile1(q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantileOut(out *Tensor, q float64, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QuantileOut(out, q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantileOut1(out *Tensor, q *Tensor, dim []int64, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QuantileOut1(out, q, dim, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantizePerChannel(scales *Tensor, zeroPoints *Tensor, axis int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QuantizePerChannel(scales, zeroPoints, axis, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantizePerTensor(scale float64, zeroPoint int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QuantizePerTensor(scale, zeroPoint, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustQuantizedBatchNorm(input *Tensor, weight *Tensor, bias *Tensor, mean *Tensor, vari *Tensor, eps float64, outputScale float64, outputZeroPoint int64)(retVal *Tensor) { 
  
  retVal, err := QuantizedBatchNorm(input, weight, bias, mean, vari, eps, outputScale, outputZeroPoint)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustQuantizedGruCell(input *Tensor, hx *Tensor, wIh *Tensor, wHh *Tensor, bIh *Tensor, bHh *Tensor, packedIh *Tensor, packedHh *Tensor, colOffsetsIh *Tensor, colOffsetsHh *Tensor, scaleIh *Scalar, scaleHh *Scalar, zeroPointIh *Scalar, zeroPointHh *Scalar)(retVal *Tensor) { 
  
  retVal, err := QuantizedGruCell(input, hx, wIh, wHh, bIh, bHh, packedIh, packedHh, colOffsetsIh, colOffsetsHh, scaleIh, scaleHh, zeroPointIh, zeroPointHh)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantizedMaxPool1d(kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QuantizedMaxPool1d(kernelSize, stride, padding, dilation, ceilMode, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustQuantizedMaxPool2d(kernelSize []int64, stride []int64, padding []int64, dilation []int64, ceilMode bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.QuantizedMaxPool2d(kernelSize, stride, padding, dilation, ceilMode, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustQuantizedRnnReluCell(input *Tensor, hx *Tensor, wIh *Tensor, wHh *Tensor, bIh *Tensor, bHh *Tensor, packedIh *Tensor, packedHh *Tensor, colOffsetsIh *Tensor, colOffsetsHh *Tensor, scaleIh *Scalar, scaleHh *Scalar, zeroPointIh *Scalar, zeroPointHh *Scalar)(retVal *Tensor) { 
  
  retVal, err := QuantizedRnnReluCell(input, hx, wIh, wHh, bIh, bHh, packedIh, packedHh, colOffsetsIh, colOffsetsHh, scaleIh, scaleHh, zeroPointIh, zeroPointHh)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustQuantizedRnnTanhCell(input *Tensor, hx *Tensor, wIh *Tensor, wHh *Tensor, bIh *Tensor, bHh *Tensor, packedIh *Tensor, packedHh *Tensor, colOffsetsIh *Tensor, colOffsetsHh *Tensor, scaleIh *Scalar, scaleHh *Scalar, zeroPointIh *Scalar, zeroPointHh *Scalar)(retVal *Tensor) { 
  
  retVal, err := QuantizedRnnTanhCell(input, hx, wIh, wHh, bIh, bHh, packedIh, packedHh, colOffsetsIh, colOffsetsHh, scaleIh, scaleHh, zeroPointIh, zeroPointHh)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRad2deg(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rad2deg(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRad2deg_()() { 
  
  err := ts.Rad2deg_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRad2degOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rad2degOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRand(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Rand(size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRandLike(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RandLike(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandOut(out *Tensor, size []int64)(retVal *Tensor) { 
  
  retVal, err := RandOut(out, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandint(high int64, size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Randint(high, size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandint1(low int64, high int64, size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Randint1(low, high, size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRandintLike(high int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RandintLike(high, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRandintLike1(low int64, high int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RandintLike1(low, high, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandintOut(out *Tensor, high int64, size []int64)(retVal *Tensor) { 
  
  retVal, err := RandintOut(out, high, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandintOut1(out *Tensor, low int64, high int64, size []int64)(retVal *Tensor) { 
  
  retVal, err := RandintOut1(out, low, high, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandn(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Randn(size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRandnLike(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RandnLike(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandnOut(out *Tensor, size []int64)(retVal *Tensor) { 
  
  retVal, err := RandnOut(out, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRandom_()() { 
  
  err := ts.Random_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRandom1_(to int64)() { 
  
  err := ts.Random1_(to)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRandom2(from int64, to []int64)() { 
  
  err := ts.Random2(from, to)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustRandperm(n int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Randperm(n, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRandpermOut(out *Tensor, n int64)(retVal *Tensor) { 
  
  retVal, err := RandpermOut(out, n)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRange(start *Scalar, end *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Range(start, end, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRange1(start *Scalar, end *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Range1(start, end, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRangeOut(out *Tensor, start *Scalar, end *Scalar)(retVal *Tensor) { 
  
  retVal, err := RangeOut(out, start, end)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReal(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Real(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReciprocal(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Reciprocal(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReciprocal_()() { 
  
  err := ts.Reciprocal_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustReciprocalOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReciprocalOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad1d(padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad1d(padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad1dBackward(gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad1dBackward(gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad1dBackwardOut(gradInput *Tensor, gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad1dBackwardOut(gradInput, gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad1dOut(out *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad1dOut(out, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad2d(padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad2d(padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad2dBackward(gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad2dBackward(gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad2dBackwardOut(gradInput, gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReflectionPad2dOut(out *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReflectionPad2dOut(out, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRelu(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Relu(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRelu_()() { 
  
  err := ts.Relu_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRemainder(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Remainder(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRemainder1(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Remainder1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRemainder_(other *Scalar)() { 
  
  err := ts.Remainder_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRemainder1_(other *Tensor)() { 
  
  err := ts.Remainder1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRemainderOut(out *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RemainderOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRemainderOut1(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RemainderOut1(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRenorm(p *Scalar, dim int64, maxnorm *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Renorm(p, dim, maxnorm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRenorm_(p *Scalar, dim int64, maxnorm *Scalar)() { 
  
  err := ts.Renorm_(p, dim, maxnorm)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRenormOut(out *Tensor, p *Scalar, dim int64, maxnorm *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RenormOut(out, p, dim, maxnorm, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRepeat(repeats []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Repeat(repeats, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRepeatInterleave(repeats *Tensor)(retVal *Tensor) { 
  
  retVal, err := RepeatInterleave(repeats)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRepeatInterleave1(repeats *Tensor, dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RepeatInterleave1(repeats, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRepeatInterleave2(repeats int64, dim []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RepeatInterleave2(repeats, dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad1d(padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad1d(padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad1dBackward(gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad1dBackward(gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad1dBackwardOut(gradInput *Tensor, gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad1dBackwardOut(gradInput, gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad1dOut(out *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad1dOut(out, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad2d(padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad2d(padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad2dBackward(gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad2dBackward(gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad2dBackwardOut(gradInput, gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad2dOut(out *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad2dOut(out, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad3d(padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad3d(padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad3dBackward(gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad3dBackward(gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad3dBackwardOut(gradInput, gradOutput, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReplicationPad3dOut(out *Tensor, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReplicationPad3dOut(out, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRequiresGrad_(requiresGrad bool)() { 
  
  err := ts.RequiresGrad_(requiresGrad)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustReshape(shape []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Reshape(shape, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustReshapeAs(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ReshapeAs(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustResize_(size []int64)() { 
  
  err := ts.Resize_(size)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustResizeAs_(theTemplate *Tensor)() { 
  
  err := ts.ResizeAs_(theTemplate)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRfft(signalNdim int64, normalized bool, onesided bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rfft(signalNdim, normalized, onesided, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRnnReluCell(input *Tensor, hx *Tensor, wIh *Tensor, wHh *Tensor, bIh *Tensor, bHh *Tensor)(retVal *Tensor) { 
  
  retVal, err := RnnReluCell(input, hx, wIh, wHh, bIh, bHh)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustRnnTanhCell(input *Tensor, hx *Tensor, wIh *Tensor, wHh *Tensor, bIh *Tensor, bHh *Tensor)(retVal *Tensor) { 
  
  retVal, err := RnnTanhCell(input, hx, wIh, wHh, bIh, bHh)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRoll(shifts []int64, dims []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Roll(shifts, dims, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRot90(k int64, dims []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rot90(k, dims, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRound(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Round(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRound_()() { 
  
  err := ts.Round_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRoundOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RoundOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRrelu(training bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rrelu(training, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRrelu_(training bool)() { 
  
  err := ts.Rrelu_(training)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRreluWithNoise(noise *Tensor, training bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RreluWithNoise(noise, training, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRreluWithNoise_(noise *Tensor, training bool)() { 
  
  err := ts.RreluWithNoise_(noise, training)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRreluWithNoiseBackward(gradOutput *Tensor, noise *Tensor, lower *Scalar, upper *Scalar, training bool, selfIsResult bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RreluWithNoiseBackward(gradOutput, noise, lower, upper, training, selfIsResult, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRreluWithNoiseOut(out *Tensor, noise *Tensor, training bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RreluWithNoiseOut(out, noise, training, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRsqrt(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rsqrt(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRsqrt_()() { 
  
  err := ts.Rsqrt_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustRsqrtOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.RsqrtOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRsub(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rsub(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustRsub1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Rsub1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustScalarTensor(s *Scalar, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := ScalarTensor(s, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustScatter(dim int64, index *Tensor, src *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Scatter(dim, index, src, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustScatter1(dim int64, index *Tensor, value *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Scatter1(dim, index, value, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustScatter_(dim int64, index *Tensor, src *Tensor)() { 
  
  err := ts.Scatter_(dim, index, src)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustScatter1_(dim int64, index *Tensor, value *Scalar)() { 
  
  err := ts.Scatter1_(dim, index, value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustScatter2(dim int64, index *Tensor, src *Tensor, reduce string)() { 
  
  err := ts.Scatter2(dim, index, src, reduce)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustScatter3(dim int64, index *Tensor, value *Scalar, reduce string)() { 
  
  err := ts.Scatter3(dim, index, value, reduce)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustScatterAdd(dim int64, index *Tensor, src *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ScatterAdd(dim, index, src, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustScatterAdd_(dim int64, index *Tensor, src *Tensor)() { 
  
  err := ts.ScatterAdd_(dim, index, src)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSearchsorted(sortedSequence *Tensor, outInt32 bool, right bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Searchsorted(sortedSequence, outInt32, right, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustSearchsorted1(sortedSequence *Tensor, selfScalar *Scalar, outInt32 bool, right bool)(retVal *Tensor) { 
  
  retVal, err := Searchsorted1(sortedSequence, selfScalar, outInt32, right)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSearchsortedOut(out *Tensor, sortedSequence *Tensor, outInt32 bool, right bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SearchsortedOut(out, sortedSequence, outInt32, right, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSelect(dim int64, index int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Select(dim, index, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustSelectBackward(grad *Tensor, inputSizes []int64, dim int64, index int64)(retVal *Tensor) { 
  
  retVal, err := SelectBackward(grad, inputSizes, dim, index)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSelu(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Selu(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSelu_()() { 
  
  err := ts.Selu_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSet_()() { 
  
  err := ts.Set_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSet1_(source *Tensor)() { 
  
  err := ts.Set1_(source)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSetRequiresGrad(r bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SetRequiresGrad(r, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSgn(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sgn(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSgn_()() { 
  
  err := ts.Sgn_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSgnOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SgnOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSigmoid(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sigmoid(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSigmoid_()() { 
  
  err := ts.Sigmoid_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustSigmoidBackward(gradOutput *Tensor, output *Tensor)(retVal *Tensor) { 
  
  retVal, err := SigmoidBackward(gradOutput, output)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustSigmoidBackwardOut(gradInput *Tensor, gradOutput *Tensor, output *Tensor)(retVal *Tensor) { 
  
  retVal, err := SigmoidBackwardOut(gradInput, gradOutput, output)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSigmoidOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SigmoidOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSign(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sign(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSign_()() { 
  
  err := ts.Sign_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSignOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SignOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSignbit(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Signbit(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSignbitOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SignbitOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSilu(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Silu(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSilu_()() { 
  
  err := ts.Silu_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSiluBackward(gradOutput *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SiluBackward(gradOutput, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSiluOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SiluOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSin(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sin(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSin_()() { 
  
  err := ts.Sin_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSinOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SinOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSinh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sinh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSinh_()() { 
  
  err := ts.Sinh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSinhOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SinhOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlice(dim int64, start int64, end int64, step int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Slice(dim, start, end, step, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustSliceBackward(grad *Tensor, inputSizes []int64, dim int64, start int64, end int64, step int64)(retVal *Tensor) { 
  
  retVal, err := SliceBackward(grad, inputSizes, dim, start, end, step)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConv3d(weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConv3d(weight, kernelSize, bias, stride, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConv3dOut(out *Tensor, weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConv3dOut(out, weight, kernelSize, bias, stride, padding, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConvDilated2d(weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, dilation []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConvDilated2d(weight, kernelSize, bias, stride, padding, dilation, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConvDilated3d(weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, dilation []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConvDilated3d(weight, kernelSize, bias, stride, padding, dilation, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConvTranspose2d(weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, outputPadding []int64, dilation []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConvTranspose2d(weight, kernelSize, bias, stride, padding, outputPadding, dilation, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConvTranspose2dOut(out *Tensor, weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, outputPadding []int64, dilation []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConvTranspose2dOut(out, weight, kernelSize, bias, stride, padding, outputPadding, dilation, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConvTranspose3d(weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, outputPadding []int64, dilation []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConvTranspose3d(weight, kernelSize, bias, stride, padding, outputPadding, dilation, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSlowConvTranspose3dOut(out *Tensor, weight *Tensor, kernelSize []int64, bias *Tensor, stride []int64, padding []int64, outputPadding []int64, dilation []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SlowConvTranspose3dOut(out, weight, kernelSize, bias, stride, padding, outputPadding, dilation, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSmm(mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Smm(mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSmoothL1Loss(target *Tensor, reduction int64, beta float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SmoothL1Loss(target, reduction, beta, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSmoothL1LossBackward(gradOutput *Tensor, target *Tensor, reduction int64, beta float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SmoothL1LossBackward(gradOutput, target, reduction, beta, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSmoothL1LossBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, reduction int64, beta float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SmoothL1LossBackwardOut(gradInput, gradOutput, target, reduction, beta, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSmoothL1LossOut(out *Tensor, target *Tensor, reduction int64, beta float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SmoothL1LossOut(out, target, reduction, beta, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftMarginLoss(target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftMarginLoss(target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftMarginLossBackward(gradOutput *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftMarginLossBackward(gradOutput, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftMarginLossBackwardOut(gradInput *Tensor, gradOutput *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftMarginLossBackwardOut(gradInput, gradOutput, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftMarginLossOut(out *Tensor, target *Tensor, reduction int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftMarginLossOut(out, target, reduction, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftmax(dim int64, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Softmax(dim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftplus(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Softplus(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftplusBackward(gradOutput *Tensor, beta *Scalar, threshold *Scalar, output *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftplusBackward(gradOutput, beta, threshold, output, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftplusBackwardOut(gradInput *Tensor, gradOutput *Tensor, beta *Scalar, threshold *Scalar, output *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftplusBackwardOut(gradInput, gradOutput, beta, threshold, output, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftplusOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftplusOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftshrink(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Softshrink(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftshrinkBackward(gradOutput *Tensor, lambd *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftshrinkBackward(gradOutput, lambd, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftshrinkBackwardOut(gradInput *Tensor, gradOutput *Tensor, lambd *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftshrinkBackwardOut(gradInput, gradOutput, lambd, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSoftshrinkOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SoftshrinkOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustSparseCooTensor(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := SparseCooTensor(size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustSparseCooTensor1(indices *Tensor, values *Tensor, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := SparseCooTensor1(indices, values, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustSparseCooTensor2(indices *Tensor, values *Tensor, size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := SparseCooTensor2(indices, values, size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSparseMask(mask *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SparseMask(mask, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSparseResize_(size []int64, sparseDim int64, denseDim int64)() { 
  
  err := ts.SparseResize_(size, sparseDim, denseDim)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSparseResizeAndClear_(size []int64, sparseDim int64, denseDim int64)() { 
  
  err := ts.SparseResizeAndClear_(size, sparseDim, denseDim)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSqrt(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sqrt(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSqrt_()() { 
  
  err := ts.Sqrt_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSqrtOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SqrtOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSquare(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Square(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSquare_()() { 
  
  err := ts.Square_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSqueeze(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Squeeze(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSqueeze1(dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Squeeze1(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSqueeze_()() { 
  
  err := ts.Squeeze_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSqueeze1_(dim int64)() { 
  
  err := ts.Squeeze1_(dim)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSspaddmm(mat1 *Tensor, mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sspaddmm(mat1, mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSspaddmmOut(out *Tensor, mat1 *Tensor, mat2 *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SspaddmmOut(out, mat1, mat2, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustStack(tensors []Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := Stack(tensors, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustStackOut(out *Tensor, tensors []Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := StackOut(out, tensors, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustStd(unbiased bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Std(unbiased, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustStd1(dim []int64, unbiased bool, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Std1(dim, unbiased, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustStdOut(out *Tensor, dim []int64, unbiased bool, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.StdOut(out, dim, unbiased, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustStft(nFft int64, hopLength []int64, winLength []int64, window *Tensor, normalized bool, onesided bool, returnComplex bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Stft(nFft, hopLength, winLength, window, normalized, onesided, returnComplex, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSub(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sub(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSub1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sub1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSub_(other *Tensor)() { 
  
  err := ts.Sub_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSub1_(other *Scalar)() { 
  
  err := ts.Sub1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSubOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SubOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSubtract(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Subtract(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSubtract1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Subtract1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSubtract_(other *Tensor)() { 
  
  err := ts.Subtract_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSubtract1_(other *Scalar)() { 
  
  err := ts.Subtract1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustSubtractOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SubtractOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSum(dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sum(dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSum1(dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Sum1(dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSumOut(out *Tensor, dim []int64, keepdim bool, dtype gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SumOut(out, dim, keepdim, dtype, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustSumToSize(size []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.SumToSize(size, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustT(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.T(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustT_()() { 
  
  err := ts.T_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustTake(index *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Take(index, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustTakeBackward(grad *Tensor, input *Tensor, index *Tensor)(retVal *Tensor) { 
  
  retVal, err := TakeBackward(grad, input, index)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTakeOut(out *Tensor, index *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TakeOut(out, index, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTan(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Tan(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTan_()() { 
  
  err := ts.Tan_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustTanOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TanOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTanh(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Tanh(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTanh_()() { 
  
  err := ts.Tanh_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustTanhBackward(gradOutput *Tensor, output *Tensor)(retVal *Tensor) { 
  
  retVal, err := TanhBackward(gradOutput, output)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustTanhBackwardOut(gradInput *Tensor, gradOutput *Tensor, output *Tensor)(retVal *Tensor) { 
  
  retVal, err := TanhBackwardOut(gradInput, gradOutput, output)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTanhOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TanhOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTensordot(other *Tensor, dimsSelf []int64, dimsOther []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Tensordot(other, dimsSelf, dimsOther, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustThreshold(threshold *Scalar, value *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Threshold(threshold, value, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustThreshold_(threshold *Scalar, value *Scalar)() { 
  
  err := ts.Threshold_(threshold, value)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustThresholdBackward(gradOutput *Tensor, threshold *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ThresholdBackward(gradOutput, threshold, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustThresholdOut(out *Tensor, threshold *Scalar, value *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ThresholdOut(out, threshold, value, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTo(device gotch.Device, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.To(device, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTo1(optionsKind gotch.DType, optionsDevice gotch.Device, nonBlocking bool, copy bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.To1(optionsKind, optionsDevice, nonBlocking, copy, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTo2(dtype gotch.DType, nonBlocking bool, copy bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.To2(dtype, nonBlocking, copy, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTo3(other *Tensor, nonBlocking bool, copy bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.To3(other, nonBlocking, copy, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTo4(device gotch.Device, dtype gotch.DType, nonBlocking bool, copy bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.To4(device, dtype, nonBlocking, copy, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustToDense(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ToDense(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustToDenseBackward(grad *Tensor, input *Tensor)(retVal *Tensor) { 
  
  retVal, err := ToDenseBackward(grad, input)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustToMkldnn(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ToMkldnn(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustToMkldnnBackward(grad *Tensor, input *Tensor)(retVal *Tensor) { 
  
  retVal, err := ToMkldnnBackward(grad, input)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustToSparse(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ToSparse(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustToSparse1(sparseDim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ToSparse1(sparseDim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTotype(scalarType gotch.DType, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Totype(scalarType, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTrace(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Trace(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustTraceBackward(grad *Tensor, sizes []int64)(retVal *Tensor) { 
  
  retVal, err := TraceBackward(grad, sizes)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTranspose(dim0 int64, dim1 int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Transpose(dim0, dim1, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTranspose_(dim0 int64, dim1 int64)() { 
  
  err := ts.Transpose_(dim0, dim1)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustTrapz(y *Tensor, x *Tensor, dim int64)(retVal *Tensor) { 
  
  retVal, err := Trapz(y, x, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustTrapz1(y *Tensor, dx float64, dim int64)(retVal *Tensor) { 
  
  retVal, err := Trapz1(y, dx, dim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTril(diagonal int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Tril(diagonal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTril_(diagonal int64)() { 
  
  err := ts.Tril_(diagonal)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustTrilIndices(row int64, col int64, offset int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := TrilIndices(row, col, offset, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTrilOut(out *Tensor, diagonal int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TrilOut(out, diagonal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustTripletMarginLoss(anchor *Tensor, positive *Tensor, negative *Tensor, margin float64, p float64, eps float64, swap bool, reduction int64)(retVal *Tensor) { 
  
  retVal, err := TripletMarginLoss(anchor, positive, negative, margin, p, eps, swap, reduction)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTriu(diagonal int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Triu(diagonal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTriu_(diagonal int64)() { 
  
  err := ts.Triu_(diagonal)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustTriuIndices(row int64, col int64, offset int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := TriuIndices(row, col, offset, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTriuOut(out *Tensor, diagonal int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TriuOut(out, diagonal, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTrueDivide(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TrueDivide(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTrueDivide1(other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TrueDivide1(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTrueDivide_(other *Tensor)() { 
  
  err := ts.TrueDivide_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustTrueDivide1_(other *Scalar)() { 
  
  err := ts.TrueDivide1_(other)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustTrueDivideOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TrueDivideOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTrunc(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Trunc(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTrunc_()() { 
  
  err := ts.Trunc_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustTruncOut(out *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TruncOut(out, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustTypeAs(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.TypeAs(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUnflatten(dim int64, sizes []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Unflatten(dim, sizes, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUnfold(dimension int64, size int64, step int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Unfold(dimension, size, step, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUnfoldBackward(gradIn *Tensor, inputSizes []int64, dim int64, size int64, step int64)(retVal *Tensor) { 
  
  retVal, err := UnfoldBackward(gradIn, inputSizes, dim, size, step)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUniform_(from float64, to float64)() { 
  
  err := ts.Uniform_(from, to)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustUnsqueeze(dim int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Unsqueeze(dim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUnsqueeze_(dim int64)() { 
  
  err := ts.Unsqueeze_(dim)
  if err != nil { log.Fatal(err) }
  
  return 
} 

func(ts *Tensor) MustUpsampleBicubic2d(outputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleBicubic2d(outputSize, alignCorners, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleBicubic2dBackward(gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleBicubic2dBackward(gradOutput, outputSize, inputSize, alignCorners, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleBicubic2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleBicubic2dBackwardOut(gradInput, gradOutput, outputSize, inputSize, alignCorners, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleBicubic2dOut(out *Tensor, outputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleBicubic2dOut(out, outputSize, alignCorners, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleBilinear2d(outputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleBilinear2d(outputSize, alignCorners, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleBilinear2dBackward(gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleBilinear2dBackward(gradOutput, outputSize, inputSize, alignCorners, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleBilinear2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleBilinear2dBackwardOut(gradInput, gradOutput, outputSize, inputSize, alignCorners, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleBilinear2dOut(out *Tensor, outputSize []int64, alignCorners bool, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleBilinear2dOut(out, outputSize, alignCorners, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleLinear1d(outputSize []int64, alignCorners bool, scales []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleLinear1d(outputSize, alignCorners, scales, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleLinear1dBackward(gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scales []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleLinear1dBackward(gradOutput, outputSize, inputSize, alignCorners, scales)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleLinear1dBackwardOut(gradInput *Tensor, gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scales []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleLinear1dBackwardOut(gradInput, gradOutput, outputSize, inputSize, alignCorners, scales)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleLinear1dOut(out *Tensor, outputSize []int64, alignCorners bool, scales []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleLinear1dOut(out, outputSize, alignCorners, scales, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleNearest1d(outputSize []int64, scales []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleNearest1d(outputSize, scales, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleNearest1dBackward(gradOutput *Tensor, outputSize []int64, inputSize []int64, scales []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleNearest1dBackward(gradOutput, outputSize, inputSize, scales)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleNearest1dBackwardOut(gradInput *Tensor, gradOutput *Tensor, outputSize []int64, inputSize []int64, scales []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleNearest1dBackwardOut(gradInput, gradOutput, outputSize, inputSize, scales)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleNearest1dOut(out *Tensor, outputSize []int64, scales []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleNearest1dOut(out, outputSize, scales, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleNearest2d(outputSize []int64, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleNearest2d(outputSize, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleNearest2dBackward(gradOutput *Tensor, outputSize []int64, inputSize []int64, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleNearest2dBackward(gradOutput, outputSize, inputSize, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleNearest2dBackwardOut(gradInput *Tensor, gradOutput *Tensor, outputSize []int64, inputSize []int64, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleNearest2dBackwardOut(gradInput, gradOutput, outputSize, inputSize, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleNearest2dOut(out *Tensor, outputSize []int64, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleNearest2dOut(out, outputSize, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleNearest3d(outputSize []int64, scalesD []float64, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleNearest3d(outputSize, scalesD, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleNearest3dBackward(gradOutput *Tensor, outputSize []int64, inputSize []int64, scalesD []float64, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleNearest3dBackward(gradOutput, outputSize, inputSize, scalesD, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleNearest3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, outputSize []int64, inputSize []int64, scalesD []float64, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleNearest3dBackwardOut(gradInput, gradOutput, outputSize, inputSize, scalesD, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleNearest3dOut(out *Tensor, outputSize []int64, scalesD []float64, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleNearest3dOut(out, outputSize, scalesD, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleTrilinear3d(outputSize []int64, alignCorners bool, scalesD []float64, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleTrilinear3d(outputSize, alignCorners, scalesD, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleTrilinear3dBackward(gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scalesD []float64, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleTrilinear3dBackward(gradOutput, outputSize, inputSize, alignCorners, scalesD, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustUpsampleTrilinear3dBackwardOut(gradInput *Tensor, gradOutput *Tensor, outputSize []int64, inputSize []int64, alignCorners bool, scalesD []float64, scalesH []float64, scalesW []float64)(retVal *Tensor) { 
  
  retVal, err := UpsampleTrilinear3dBackwardOut(gradInput, gradOutput, outputSize, inputSize, alignCorners, scalesD, scalesH, scalesW)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustUpsampleTrilinear3dOut(out *Tensor, outputSize []int64, alignCorners bool, scalesD []float64, scalesH []float64, scalesW []float64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.UpsampleTrilinear3dOut(out, outputSize, alignCorners, scalesD, scalesH, scalesW, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustValueSelectingReductionBackward(grad *Tensor, dim int64, indices *Tensor, sizes []int64, keepdim bool)(retVal *Tensor) { 
  
  retVal, err := ValueSelectingReductionBackward(grad, dim, indices, sizes, keepdim)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustValues(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Values(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustVander(x *Tensor, n []int64, increasing bool)(retVal *Tensor) { 
  
  retVal, err := Vander(x, n, increasing)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustVar(unbiased bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Var(unbiased, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustVar1(dim []int64, unbiased bool, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Var1(dim, unbiased, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustVarOut(out *Tensor, dim []int64, unbiased bool, keepdim bool, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.VarOut(out, dim, unbiased, keepdim, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustVdot(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Vdot(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustVdotOut(out *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.VdotOut(out, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustView(size []int64, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.View(size, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustViewAs(other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ViewAs(other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustViewAsComplex(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ViewAsComplex(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustViewAsReal(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ViewAsReal(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustVstack(tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := Vstack(tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustVstackOut(out *Tensor, tensors []Tensor)(retVal *Tensor) { 
  
  retVal, err := VstackOut(out, tensors)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustWhere1(condition *Tensor, other *Tensor, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Where1(condition, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustWhere2(condition *Tensor, selfScalar *Scalar, other *Tensor)(retVal *Tensor) { 
  
  retVal, err := Where2(condition, selfScalar, other)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustWhere3(condition *Tensor, other *Scalar, del bool)(retVal *Tensor) { 
  
  retVal, err := ts.Where3(condition, other, del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustWhere4(condition *Tensor, selfScalar *Scalar, other *Scalar)(retVal *Tensor) { 
  
  retVal, err := Where4(condition, selfScalar, other)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustZero_()() { 
  
  err := ts.Zero_()
  if err != nil { log.Fatal(err) }
  
  return 
} 

func MustZeros(size []int64, optionsKind gotch.DType, optionsDevice gotch.Device)(retVal *Tensor) { 
  
  retVal, err := Zeros(size, optionsKind, optionsDevice)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func(ts *Tensor) MustZerosLike(del bool)(retVal *Tensor) { 
  
  retVal, err := ts.ZerosLike(del)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 

func MustZerosOut(out *Tensor, size []int64)(retVal *Tensor) { 
  
  retVal, err := ZerosOut(out, size)
  if err != nil { log.Fatal(err) }
  
  return retVal
} 
// End of implementing Tensor ================================= 
